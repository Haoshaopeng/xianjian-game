<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>VIVID WORLD: INTERACTIVE</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€ --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top:0; left:0; z-index: 1; }
        
        /* --- HUD --- */
        #hud-layer {
            position: absolute; top: 10px; left: 10px;
            color: #fff; font-family: 'Consolas', monospace; z-index: 20; pointer-events: none;
            background: linear-gradient(90deg, rgba(0,0,0,0.8), transparent);
            padding: 10px; border-left: 3px solid #00f0ff;
            text-shadow: 0 0 5px rgba(0, 240, 255, 0.8);
            transform: scale(0.8); transform-origin: top left;
        }
        .hud-item { margin-bottom: 5px; font-size: 16px; display: flex; align-items: center; }
        .vehicle-icon { font-size: 20px; margin-right: 10px; width: 25px; text-align: center; }
        .status-ok { color: #00ff00; }
        
        /* --- åŠ¨æ€æ°”æ³¡ --- */
        .chat-bubble {
            position: absolute; background: rgba(0, 20, 30, 0.9); border: 1px solid #00f0ff; color: #00f0ff;
            padding: 8px 12px; border-radius: 8px; font-size: 12px; pointer-events: none; max-width: 180px;
            transform: translate(-50%, -100%); margin-top: -20px; opacity: 0; transition: opacity 0.3s; z-index: 15;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.2); text-align: center; white-space: pre-wrap;
        }
        .chat-bubble::after {
            content: ''; position: absolute; bottom: -6px; left: 50%; margin-left: -6px;
            border-width: 6px 6px 0; border-style: solid; border-color: #00f0ff transparent transparent transparent;
        }
        .chat-bubble.npc { border-color: #ffaa00; color: #ffaa00; box-shadow: 0 0 10px rgba(255, 170, 0, 0.3); z-index: 14; }
        .chat-bubble.npc::after { border-color: #ffaa00 transparent transparent transparent; }
        .chat-bubble.user { border-color: #ffffff; color: #ffffff; box-shadow: 0 0 10px rgba(255, 255, 255, 0.3); z-index: 16; }
        .chat-bubble.user::after { border-color: #ffffff transparent transparent transparent; }

        /* --- ç§»åŠ¨ç«¯æ§åˆ¶å™¨ --- */
        .control-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 30; pointer-events: none; }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 180px; height: 180px; pointer-events: auto; }
        .joystick-base {
            position: absolute; top: 50%; left: 50%; width: 120px; height: 120px; transform: translate(-50%, -50%);
            border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2);
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.1) 100%);
            transition: opacity 0.2s;
        }
        .joystick-stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; transform: translate(-50%, -50%);
            border-radius: 50%; background: rgba(0, 240, 255, 0.8); box-shadow: 0 0 15px #00f0ff; pointer-events: none;
        }
        #camera-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; z-index: 29; pointer-events: auto; }
        
        #action-zone { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 15px; align-items: flex-end; pointer-events: auto; }
        .action-btn {
            width: 70px; height: 70px; border-radius: 50%; background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5); color: #fff; display: flex; justify-content: center; align-items: center;
            font-size: 28px; backdrop-filter: blur(5px); transition: transform 0.1s, background 0.1s; cursor: pointer;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            -webkit-tap-highlight-color: transparent; /* ç§»é™¤ç‚¹å‡»é«˜äº® */
        }
        .action-btn:active { transform: scale(0.9); background: rgba(0, 240, 255, 0.4); border-color: #00f0ff; }
        
        /* ä¸åŒçš„æŒ‰é’®æ ·å¼ */
        #btn-fly { border-color: #ff3366; background: rgba(40, 10, 20, 0.6); }
        #btn-fly:active { background: #ff3366; }
        #btn-car { border-color: #ffff00; background: rgba(40, 40, 10, 0.6); }
        #btn-car:active { background: #ffff00; color: #000; }
        #btn-walk { border-color: #00ff00; background: rgba(10, 40, 10, 0.6); display: none; }
        
        #btn-jump { 
            width: 90px; height: 90px; border-color: #00f0ff; 
            background: rgba(0, 20, 40, 0.7); font-size: 32px;
            margin-left: 10px;
        }

        /* --- äº¤äº’æç¤º --- */
        #interaction-prompt {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            color: #ffaa00; font-size: 16px; font-weight: bold; display: none; z-index: 25;
            text-shadow: 0 0 10px #ffaa00; pointer-events: none; letter-spacing: 2px;
            background: rgba(0, 0, 0, 0.6); padding: 10px 30px; border: 1px solid #ffaa00; border-radius: 4px;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { opacity: 0.8; box-shadow: 0 0 10px #ffaa00; } to { opacity: 1; box-shadow: 0 0 20px #ffaa00; } }
        
        #target-indicator {
            position: absolute; top: 120px; left: 10px;
            color: #ffaa00; font-family: 'Consolas', monospace; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 5px; border: 1px solid #ffaa00;
            display: none; z-index: 20;
        }

        /* --- æŒ‡ä»¤æ§åˆ¶å° --- */
        #command-interface {
            position: absolute; top: 10px; right: 10px; width: 240px; pointer-events: auto; z-index: 35; display: flex; flex-direction: column; gap: 5px; opacity: 0.9;
        }
        #ai-log {
            background: rgba(0, 20, 30, 0.9); border: 1px solid #00f0ff; padding: 5px; height: 100px;
            overflow-y: auto; color: #ccffff; font-size: 10px; font-family: monospace; scrollbar-width: none;
            display: flex; flex-direction: column; justify-content: flex-end; pointer-events: none;
        }
        .input-group { display: flex; gap: 5px; }
        #command-input {
            flex-grow: 1; background: rgba(0, 0, 0, 0.6); border: 1px solid #00f0ff; color: #fff;
            padding: 5px; outline: none; font-family: monospace; font-size: 12px; border-radius: 4px;
        }
        #mic-btn { background: rgba(0, 40, 50, 0.8); border: 1px solid #00f0ff; color: #00f0ff; width: 30px; cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #mic-btn.listening { background: #00f0ff; color: #000; }

        /* --- é®ç½©å±‚ (Keyè¾“å…¥) --- */
        #blocker {
            position: absolute; width: 100%; height: 100%; background: #000;
            display: flex; align-items: center; justify-content: center; z-index: 100;
            flex-direction: column; 
        }
        #instructions {
            color: #fff; text-align: center; padding: 20px; width: 80%; max-width: 400px;
            border: 1px solid #00f0ff; background: rgba(0, 20, 30, 0.95);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.3); border-radius: 10px;
        }
        .api-input {
            width: 90%; padding: 10px; margin: 15px 0; background: rgba(0,0,0,0.5); 
            border: 1px solid #333; color: #fff; border-radius: 4px; font-family: monospace;
        }
        .start-btn {
            background: #00f0ff; color: #000; border: none; padding: 10px 30px; 
            font-weight: bold; cursor: pointer; border-radius: 4px; font-size: 16px;
        }
        h1 { color: #00f0ff; margin: 0 0 20px 0; font-size: 24px; letter-spacing: 2px; }
        .rotate-hint { display: none; color: #ff3366; font-size: 20px; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 200; justify-content: center; align-items: center; text-align: center; }
        @media screen and (orientation: portrait) { .rotate-hint { display: flex; } #blocker, #hud-layer, #command-interface { display: none; } }
    </style>
</head>
<body>

    <div class="rotate-hint">
        <div>âš ï¸ è¯·æ—‹è½¬æ‰‹æœºè‡³æ¨ªå± âš ï¸</div>
    </div>

    <div id="canvas-container"></div>
    <div id="bubble-container"></div>

    <div id="hud-layer">
        <div class="hud-item"><span id="mode-icon" class="vehicle-icon">ğŸƒ</span><span id="mode-text">æ­¥è¡Œ</span></div>
        <div class="hud-item"><span class="vehicle-icon">âŒš</span><span id="time-text">12:00</span></div>
        <div class="hud-item"><span class="vehicle-icon">âš¡</span><span id="speed-text">0</span> km/h</div>
        <div class="hud-item"><span class="vehicle-icon">ğŸ§ </span>AI: <span id="ai-status" class="status-ok">ç¦»çº¿</span></div>
    </div>

    <div id="target-indicator">å½“å‰é€šè¯å¯¹è±¡: å¸‚æ°‘ #<span id="target-id">--</span></div>
    <div id="interaction-prompt">ğŸ‘‹ ç‚¹å‡»äº¤è°ˆ</div>

    <div class="control-layer">
        <div id="joystick-zone"></div>
        <div id="camera-zone"></div>
        <div id="action-zone">
            <div class="action-btn" id="btn-interact" style="display:none;">ğŸ’¬</div>
            <div class="action-btn" id="btn-walk">ğŸƒ</div>
            <div class="action-btn" id="btn-car">ğŸï¸</div>
            <div class="action-btn" id="btn-fly">ğŸš€</div>
            <div class="action-btn" id="btn-jump">ğŸ†™</div>
        </div>
    </div>

    <div id="command-interface">
        <div id="ai-log">
            <div style="color: #888;">> ç³»ç»Ÿåˆå§‹åŒ–...</div>
        </div>
        <div class="input-group">
            <input type="text" id="command-input" placeholder="è¾“å…¥æŒ‡ä»¤/èŠå¤©..." autocomplete="off">
            <button id="mic-btn">ğŸ¤</button>
        </div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <h1>VIVID WORLD // V4.3 INTERACT</h1>
            <p style="font-size:12px; color:#aaa;">æ¥å…¥ Gemini çŸ©é˜µä»¥æ¿€æ´»å®Œå…¨æ™ºèƒ½</p>
            <div style="height: 1px; background: #005566; margin: 15px 0;"></div>
            
            <input type="password" id="api-key-input" class="api-input" placeholder="è¾“å…¥ Google API Key (å¯é€‰)">
            <p style="font-size: 10px; color: #666; margin-top:-10px; margin-bottom: 20px;">*ç•™ç©ºåˆ™ä½¿ç”¨æœ¬åœ°æ¨¡æ‹Ÿæ¨¡å¼</p>
            
            <button class="start-btn" id="start-game-btn">æ¥å…¥ç³»ç»Ÿ</button>
            
            <p style="font-size: 12px; color: #666; margin-top: 15px;">æ™ºèƒ½æ³¨è§† Â· è‡ªåŠ¨é©»è¶³ Â· è¯­å¢ƒæ„ŸçŸ¥</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- ç³»ç»Ÿå˜é‡ ---
        let camera, scene, renderer, world, playerBody;
        let isGameActive = false;
        let lastTime = 0;
        let yawObject, pitchObject;
        let apiKey = ""; 
        let chatTarget = null; 
        let chatTargetTimer = 0;
        
        // --- æ¸¸æˆçŠ¶æ€ ---
        let time = 0, dayTime = 0.45;
        const touchState = { moveVector: new THREE.Vector2(0, 0), isSprinting: false };
        let currentVehicle = 'walk';
        
        // --- ğŸš€ è½½å…·å‚æ•°å¼ºåŒ– ---
        const vehicleSettings = {
            walk: { 
                speed: 12, jump: 8, height: 1.7, fly: false, gravity: -20, damping: 0.1, 
                icon: 'ğŸƒ', name: 'æ­¥è¡Œ', camDist: 0, camHeight: 0 
            },
            car:  { 
                speed: 120, jump: 0, height: 1.0, fly: false, gravity: -30, damping: 0.5, 
                icon: 'ğŸï¸', name: 'æé€Ÿ', camDist: 2, camHeight: -0.5 
            },
            plane: { 
                speed: 80, jump: 30, height: 5.0, fly: true, gravity: 0, damping: 0.8, 
                icon: 'âœˆï¸', name: 'é£è¡Œ', camDist: 4, camHeight: 0 
            }
        };

        // --- èµ„æºä¸å¯¹è±¡ ---
        const visualMeshes = [], interactables = [], cars = [], npcs = [];
        let buildingMaterials = [];
        let terrainMesh, waterMesh, terrainBody;
        let roadTexture, crosswalkTexture, windowTexture, lightPoolTexture;
        let roadData = []; 
        let sunLight, ambientLight, sunMesh, fog, weatherParticles;
        let aiDrone = { mesh: null, ring1: null, ring2: null, core: null };
        const activeBubbles = [];
        const ui = {};
        let raycaster = new THREE.Raycaster();

        // --- ğŸ”Š éŸ³æ•ˆç³»ç»Ÿ ---
        class SoundFX {
            constructor() {
                this.ctx = null;
                this.footstepTimer = 0;
                this.masterGain = null;
            }
            init() {
                if (this.ctx) return;
                try {
                    const AC = window.AudioContext || window.webkitAudioContext; 
                    this.ctx = new AC();
                    this.masterGain = this.ctx.createGain(); 
                    this.masterGain.gain.value = 0.4;
                    this.masterGain.connect(this.ctx.destination);
                } catch(e) { console.warn("Audio init failed", e); }
            }
            resume() { 
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().then(() => console.log("Audio Resumed"));
                }
            }
            
            playTone(freq, type, duration, vol=0.1, when=0) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator(); osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime + when);
                const g = this.ctx.createGain(); g.gain.setValueAtTime(vol, this.ctx.currentTime + when);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + when + duration);
                osc.connect(g); g.connect(this.masterGain);
                osc.start(this.ctx.currentTime + when); osc.stop(this.ctx.currentTime + when + duration + 0.1);
            }

            playFootstep(interval) {
                if(!this.ctx || currentVehicle !== 'walk') return;
                if(this.ctx.currentTime > this.footstepTimer) {
                    this.playTone(100 + Math.random()*50, 'triangle', 0.05, 0.2);
                    this.footstepTimer = this.ctx.currentTime + interval;
                }
            }
            playChatBlip(isAI) {
                if(!this.ctx) return;
                if(isAI) { this.playTone(800, 'sine', 0.1, 0.1); this.playTone(1200, 'sine', 0.1, 0.1, 0.1); } 
                else { this.playTone(400 + Math.random()*200, 'sine', 0.15, 0.1); }
            }
            playEngineStart() {
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(200, 'sawtooth', 0.8, 0.2, 0.2);
            }
            playRocketLaunch() {
                this.playTone(50, 'square', 1.0, 0.5);
                this.playTone(150, 'sawtooth', 2.0, 0.2);
            }
            playInteract() { this.playTone(600, 'square', 0.1, 0.05); }
        }
        const sfx = new SoundFX();

        // --- ç©ºé—´éŸ³é¢‘ ---
        class SpatialAudioEngine {
            constructor() { this.carPool = []; this.maxSources = 6; }
            init() {
                if (!sfx.ctx) return;
                for(let i=0; i<this.maxSources; i++) this.carPool.push(this.createCarSource());
            }
            createCarSource() {
                const osc = sfx.ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = 60; osc.start();
                const panner = sfx.ctx.createPanner(); panner.panningModel = 'HRTF'; panner.distanceModel = 'inverse';
                panner.refDistance = 10; panner.maxDistance = 300;
                const gain = sfx.ctx.createGain(); gain.gain.value = 0;
                osc.connect(panner); panner.connect(sfx.masterGain);
                return { osc, panner, gain, active: false };
            }
            update(pos, cars) {
                if(!sfx.ctx) return;
                const L = sfx.ctx.listener;
                if(L.positionX) { L.positionX.value=pos.x; L.positionY.value=pos.y; L.positionZ.value=pos.z; } else L.setPosition(pos.x, pos.y, pos.z);
                cars.forEach(c => c.distSq = c.mesh.position.distanceToSquared(pos)); cars.sort((a,b)=>a.distSq-b.distSq);
                this.carPool.forEach((s, i) => {
                    const c = cars[i];
                    if (c && c.distSq < 250000) {
                        s.gain.gain.setTargetAtTime(0.15, sfx.ctx.currentTime, 0.1);
                        s.panner.setPosition(c.mesh.position.x, c.mesh.position.y, c.mesh.position.z);
                        const freq = THREE.MathUtils.clamp(60 + c.speed * 2, 30, 600);
                        s.osc.frequency.setTargetAtTime(freq, sfx.ctx.currentTime, 0.1);
                    } else s.gain.gain.setTargetAtTime(0, sfx.ctx.currentTime, 0.5);
                });
            }
        }
        const spatialAudio = new SpatialAudioEngine();

        // --- çŸ¥è¯†åº“ ---
        const npcDialogues = ["å¦‚æœä½ å»å¸‚ä¸­å¿ƒï¼Œè®°å¾—å¸¦ä¼ã€‚", "æœ€è¿‘çš„èŠ¯ç‰‡ä»·æ ¼åˆæ¶¨äº†ã€‚", "å¬è¯´ç¬¬ä¸ƒåŒºæ˜¨æ™šæœ‰éæ³•èµ›è½¦ã€‚", "æˆ‘å¾—èµ¶åœ¨å¤©é»‘å‰å›å®¶ã€‚", "è¿™åŸå¸‚çš„éœ“è™¹ç¯çœ‹ä¹…äº†çœ¼ç›ç–¼ã€‚", "ä½ æ˜¯æ–°æ¥çš„å—ï¼Ÿè£…å¤‡ä¸é”™ã€‚"];
        
        // æƒ…å¢ƒåŒ–é—®å€™è¯­
        const smartGreetings = {
            walk: ["å—¨ï¼Œèµ°è·¯é”»ç‚¼èº«ä½“å—ï¼Ÿ", "è¿™é™„è¿‘å¾ˆå®‰å…¨ï¼Œæ”¾å¿ƒé€›ã€‚", "å½“å¿ƒè„šä¸‹çš„ç§¯æ°´ã€‚", "ä½ çœ‹ä¸Šå»è¿·è·¯äº†ï¼Ÿ", "å€Ÿè¿‡ä¸€ä¸‹ã€‚", "ä»Šå¤©å¤©æ°”ä¸é”™ã€‚"],
            car: ["å“‡ï¼Œå¥½é…·çš„è½¦ï¼", "å˜¿ï¼æ³¨æ„é™é€Ÿï¼", "è¿™å¼•æ“å£°çœŸå¸¦åŠ²ã€‚", "èƒ½å¸¦æˆ‘å…œä¸€åœˆå—ï¼Ÿ", "å°å¿ƒåˆ«æ’åˆ°äººï¼", "è¿™è½¦æ˜¯æœ€æ–°æ¬¾å—ï¼Ÿ"],
            plane: ["å¤©å“ªï¼Œé‚£æ˜¯åé‡åŠ›è£…ç½®å—ï¼Ÿ", "é£è¿™ä¹ˆä½å¾ˆå±é™©ï¼", "å¸¦æˆ‘é£ï¼", "ä¸Šé¢ç©ºæ°”æ€ä¹ˆæ ·ï¼Ÿ", "å¿«çœ‹ï¼Œé‚£æ˜¯é’¢é“ä¾ å—ï¼Ÿ", "åˆ«æ‰ä¸‹æ¥ç ¸åˆ°æˆ‘ï¼"]
        };

        const localKnowledge = {
            "è°": "æˆ‘æ˜¯ ECHOï¼Œæˆ˜æœ¯è¾…åŠ©å•å…ƒã€‚", "ä½ å¥½": "ç³»ç»Ÿåœ¨çº¿ã€‚éšæ—¶å¾…å‘½ã€‚", "default": ["æˆ‘åœ¨å¬ã€‚", "ä¿¡å·æ­£å¸¸ã€‚", "è¯·æŒ‡ç¤ºã€‚", "åˆ†æå‘¨å›´ç¯å¢ƒä¸­..."]
        };

        init();

        function init() {
            // UI Binding
            ui.modeIcon = document.getElementById('mode-icon'); ui.modeText = document.getElementById('mode-text');
            ui.time = document.getElementById('time-text'); ui.speed = document.getElementById('speed-text');
            ui.aiStatus = document.getElementById('ai-status'); ui.log = document.getElementById('ai-log');
            ui.input = document.getElementById('command-input'); ui.prompt = document.getElementById('interaction-prompt');
            ui.bubbles = document.getElementById('bubble-container');
            ui.targetInd = document.getElementById('target-indicator');
            ui.targetId = document.getElementById('target-id');
            ui.btnWalk = document.getElementById('btn-walk');
            ui.btnCar = document.getElementById('btn-car');
            ui.btnFly = document.getElementById('btn-fly');
            ui.btnJump = document.getElementById('btn-jump');

            document.getElementById('start-game-btn').addEventListener('click', startGame);
            
            // Textures & Assets
            createRoadTextures(); createWindowTexture(); createLightPoolTexture();
            
            // 3D & Physics
            initThree(); initPhysics(); initWorld(); initAI_Upgraded();
            
            // Input
            setupControls(); initVoice();
            
            // Loop
            animate();
        }

        function startGame() {
            const keyInput = document.getElementById('api-key-input').value.trim();
            if(keyInput) {
                apiKey = keyInput;
                ui.aiStatus.innerText = "åœ¨çº¿";
                ui.aiStatus.className = "status-ok";
                addLog("Gemini API å·²æ¥å…¥ã€‚", false);
            } else {
                addLog("ç¦»çº¿æ¨¡å¼å¯åŠ¨ã€‚", false);
            }

            document.getElementById('blocker').style.display = 'none';
            isGameActive = true;
            try { if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{}); } catch(e){}
            
            sfx.init(); sfx.resume(); spatialAudio.init();
            setTimeout(() => aiSpeak("ç³»ç»Ÿå°±ç»ªã€‚å…¨ç³»ç»Ÿç»¿ç¯ã€‚"), 1000);
        }

        // --- åœºæ™¯ ---
        function initWorld() {
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 1.2); sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(1024,1024); sunLight.shadow.camera.top=500; sunLight.shadow.camera.bottom=-500; sunLight.shadow.camera.left=-500; sunLight.shadow.camera.right=500;
            scene.add(sunLight);
            sunMesh = new THREE.Mesh(new THREE.SphereGeometry(30), new THREE.MeshBasicMaterial({color:0xffaa00})); scene.add(sunMesh);

            const geo = new THREE.BufferGeometry();
            const pos = []; for(let i=0; i<8000; i++) pos.push((Math.random()-0.5)*1000, Math.random()*200, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            weatherParticles = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xaaaaaa, size: 0.2, transparent: true}));
            weatherParticles.visible = false; scene.add(weatherParticles);

            initTerrain();
            initCity();
            initTraffic(60); 
            initRealNPCs(50);
        }

        function initTerrain() {
            if(terrainMesh) scene.remove(terrainMesh); if(terrainBody) world.removeBody(terrainBody);
            const sz = 2000;
            const geo = new THREE.PlaneGeometry(sz, sz, 64, 64); geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++) pos.setY(i, getTerrainHeight(pos.getX(i), pos.getZ(i))); 
            geo.computeVertexNormals();
            terrainMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.9 }));
            terrainMesh.receiveShadow = true; scene.add(terrainMesh);
            
            const matrix = []; const s=32;
            for(let i=0; i<s; i++) { matrix.push([]); for(let j=0; j<s; j++) matrix[i].push(getTerrainHeight((i/(s-1)-0.5)*sz, -(j/(s-1)-0.5)*sz)); }
            terrainBody = new CANNON.Body({ mass: 0 }); 
            terrainBody.addShape(new CANNON.Heightfield(matrix, { elementSize: sz/(s-1) }));
            terrainBody.position.set(-sz/2, 0, sz/2); terrainBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(terrainBody);
        }

        function getTerrainHeight(x, z) {
            let y = Math.sin(x * 0.002) * 15 + Math.cos(z * 0.002) * 15;
            if(Math.abs(z - Math.sin(x*0.005)*50) < 120) y -= 10;
            return y;
        }

        function initCity() {
            visualMeshes.forEach(m=>scene.remove(m)); visualMeshes.length=0; interactables.length=0;
            roadData = [];
            const OVERPASS_Z = -200;
            createBridgeSegment(-1000, OVERPASS_Z, 2000, 30, 'x', 30);

            const gridSpacing = 120, segmentLen = 40;
            for(let z = -800; z <= 800; z += gridSpacing) {
                roadData.push({type:'x', z:z});
                for(let x = -800; x < 800; x += segmentLen) {
                    const cx = x + segmentLen/2;
                    if((Math.abs(x)%gridSpacing < 40) && (Math.abs(z)%gridSpacing === 0)) createIntersection(cx, getTerrainHeight(cx, z)+0.15, z);
                    else createRoadSegment(cx, z, segmentLen, 20, 'x');
                }
            }
            for(let x = -800; x <= 800; x += gridSpacing) {
                roadData.push({type:'z', x:x});
                for(let z = -800; z < 800; z += segmentLen) {
                    const cz = z + segmentLen/2;
                    if(!(Math.abs(z)%gridSpacing < 40)) createRoadSegment(x, cz, segmentLen, 20, 'z');
                }
            }
            createRamp();

            const boxGeo = new THREE.BoxGeometry(1,1,1);
            for(let i=0; i<300; i++) {
                const x = (Math.random()-0.5)*1400, z = (Math.random()-0.5)*1400;
                let safe = true;
                for(let r of roadData) if((r.type==='x' && Math.abs(z-r.z)<15) || (r.type==='z' && Math.abs(x-r.x)<15)) safe=false;
                if(!safe || Math.abs(z - OVERPASS_Z) < 30) continue;

                const h = 20+Math.random()*100, w = 10+Math.random()*15, y = getTerrainHeight(x,z);
                const mat = new THREE.MeshStandardMaterial({color: Math.random()*0x888888, roughness: 0.3, emissiveMap: windowTexture, emissive: 0xffffff, emissiveIntensity: 0});
                buildingMaterials.push(mat);
                const mesh = new THREE.Mesh(boxGeo, mat);
                mesh.position.set(x, y+h/2-5, z); mesh.scale.set(w, h, w);
                
                mesh.castShadow=true; mesh.receiveShadow=true; scene.add(mesh); visualMeshes.push(mesh);
                const body = new CANNON.Body({mass:0}); body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, w/2)), new CANNON.Vec3(x, y+h/2-5, z)); world.addBody(body);
            }
        }

        // --- çº¹ç†ä¸ç»„ä»¶ ---
        function createRoadTextures() {
            const c = document.createElement('canvas'); c.width=512; c.height=512; const ctx=c.getContext('2d');
            ctx.fillStyle='#181818'; ctx.fillRect(0,0,512,512); ctx.fillStyle='#fff';
            ctx.fillRect(5,0,8,512); ctx.fillRect(499,0,8,512);
            for(let y=0; y<512; y+=64) ctx.fillRect(254,y+16,4,32);
            roadTexture = new THREE.CanvasTexture(c); roadTexture.wrapS=roadTexture.wrapT=THREE.RepeatWrapping; roadTexture.anisotropy=4;
            
            const c2=document.createElement('canvas'); c2.width=512; c2.height=256; const ctx2=c2.getContext('2d');
            ctx2.fillStyle='#181818'; ctx2.fillRect(0,0,512,256); ctx2.fillStyle='#eee';
            for(let x=25; x<487; x+=40) ctx2.fillRect(x,25,25,206);
            crosswalkTexture = new THREE.CanvasTexture(c2); crosswalkTexture.anisotropy=4;
        }
        function createWindowTexture() {
            const c=document.createElement('canvas'); c.width=256; c.height=256; const ctx=c.getContext('2d');
            ctx.fillStyle='#000'; ctx.fillRect(0,0,256,256);
            for(let y=0; y<256; y+=16) for(let x=0; x<256; x+=8) if(Math.random()>0.9) { ctx.fillStyle=Math.random()>0.8?'#fa5':'#8cf'; ctx.fillRect(x+1,y+1,6,14); }
            windowTexture = new THREE.CanvasTexture(c); windowTexture.wrapS=windowTexture.wrapT=THREE.RepeatWrapping;
        }
        function createLightPoolTexture() {
            const c=document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d');
            const g=ctx.createRadialGradient(32,32,0,32,32,32); g.addColorStop(0,'rgba(255,200,100,0.5)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64); lightPoolTexture = new THREE.CanvasTexture(c);
        }
        function createBridgeSegment(x, z, len, w, axis, y) {
            const geo = new THREE.BoxGeometry(len, 2, w); if(axis==='z') geo.rotateY(Math.PI/2);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0x555555}));
            mesh.position.set(x + (axis==='x'?len/2:0), y, z + (axis==='z'?len/2:0));
            mesh.receiveShadow = true; scene.add(mesh); visualMeshes.push(mesh);
            const body = new CANNON.Body({mass:0});
            body.addShape(new CANNON.Box(new CANNON.Vec3(len/2, 1, w/2)), new CANNON.Vec3(mesh.position.x, y, mesh.position.z));
            if(axis==='z') body.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), Math.PI/2);
            world.addBody(body);
        }
        function createRoadSegment(x, z, len, w, axis) {
            const geo = new THREE.PlaneGeometry(len, w); geo.rotateX(-Math.PI/2); if(axis==='z') geo.rotateY(Math.PI/2);
            const pos = geo.attributes.position; for(let i=0; i<pos.count; i++) pos.setY(i, getTerrainHeight(x+pos.getX(i), z+pos.getZ(i))+0.15);
            geo.computeVertexNormals();
            const tex = roadTexture.clone(); tex.rotation = Math.PI/2; tex.center.set(0.5,0.5); tex.repeat.set(1, len/40);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({map:tex, color:0xffffff}));
            mesh.position.set(x,0,z); mesh.receiveShadow=true; scene.add(mesh); visualMeshes.push(mesh);
            if(Math.random()>0.8) createStreetLight(axis==='x'?x:x+12, getTerrainHeight(x,z), axis==='x'?z+12:z);
        }
        function createIntersection(x, y, z) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(22, 22), new THREE.MeshStandardMaterial({ map: crosswalkTexture, roughness: 0.8 }));
            mesh.rotation.x = -Math.PI/2; mesh.position.set(x, y, z);
            scene.add(mesh); visualMeshes.push(mesh);
            createStreetLight(x+12, y, z-12);
        }
        function createRamp() {
            for(let i=0; i<20; i++) {
                const alpha = i/20; const rX = 200 - 10; const rZ = 0 + alpha * (-200 - 0); 
                const rY = THREE.MathUtils.lerp(getTerrainHeight(rX,0), 30, alpha*alpha); 
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(15, 20), new THREE.MeshStandardMaterial({color: 0x555555}));
                mesh.rotation.x = -Math.PI/2; mesh.position.set(rX, rY, rZ);
                mesh.lookAt(rX, rY + (30-getTerrainHeight(rX,0))/20, rZ - 20); 
                scene.add(mesh); visualMeshes.push(mesh);
            }
        }
        function createStreetLight(x, y, z) {
            const g = new THREE.Group(); g.position.set(x,y,z);
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,8), new THREE.MeshStandardMaterial({color:0x222})); p.position.y=4; g.add(p);
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xffaa55})); b.position.set(0,8,0); g.add(b);
            const pl = new THREE.Mesh(new THREE.PlaneGeometry(25,25), new THREE.MeshBasicMaterial({map:lightPoolTexture, transparent:true, opacity:0, depthWrite:false, blending:THREE.AdditiveBlending}));
            pl.rotation.x=-Math.PI/2; pl.position.y=0.1; g.add(pl);
            scene.add(g); visualMeshes.push(g);
        }

        function initTraffic(count) {
            cars.forEach(c => scene.remove(c.mesh)); cars.length=0;
            const carGeo = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.8,4.5), new THREE.MeshStandardMaterial({color:0xffffff})); b.position.y=0.6; carGeo.add(b);
            const c = new THREE.Mesh(new THREE.BoxGeometry(2,0.7,2.5), new THREE.MeshStandardMaterial({color:0x88ccff, transparent:true, opacity:0.6})); c.position.set(0,1.35,-0.2); carGeo.add(c);
            
            for(let i=0; i<count; i++) {
                const car = carGeo.clone(); car.children[0].material = new THREE.MeshStandardMaterial({color:Math.random()*0xffffff});
                const onBridge = Math.random() > 0.6;
                let x,y,z,dir,axis;
                if(onBridge) { x=(Math.random()-0.5)*1500; z=-200 + (Math.random()>0.5?5:-5); y=30.5; axis='x'; dir=Math.random()>0.5?1:-1; car.rotation.y = dir>0 ? Math.PI/2 : -Math.PI/2; } 
                else { const lanes = [-400, -200, 0, 200, 400]; z = lanes[Math.floor(Math.random()*lanes.length)]; x = (Math.random()-0.5)*1500; y = 10.5; axis='z'; dir=Math.random()>0.5?1:-1; car.rotation.y = dir>0 ? 0 : Math.PI; }
                car.position.set(x,y,z); scene.add(car); cars.push({mesh:car, speed:15+Math.random()*20, dir, axis, onBridge});
            }
        }
        function updateTraffic(dt) {
            cars.forEach(c => {
                const move = c.speed * dt * c.dir;
                if(c.axis==='x') c.mesh.position.x += move; else c.mesh.position.z += move;
                if(!c.onBridge) {
                    const h = getTerrainHeight(c.mesh.position.x, c.mesh.position.z); c.mesh.position.y = h + 0.5;
                    const fwd = new THREE.Vector3(c.axis==='x'?c.dir:0, 0, c.axis==='z'?c.dir:0);
                    const target = c.mesh.position.clone().add(fwd); target.y = getTerrainHeight(target.x, target.z)+0.5;
                    c.mesh.lookAt(target);
                }
                if(Math.abs(c.axis==='x'?c.mesh.position.x:c.mesh.position.z)>1000) { if(c.axis==='x') c.mesh.position.x*=-1; else c.mesh.position.z*=-1; }
            });
        }

        function initAI_Upgraded() {
            const g = new THREE.Group();
            const core = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({color: 0x00f0ff, emissive: 0x00f0ff, emissiveIntensity: 2}));
            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.02, 8, 32), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.6}));
            const ring2 = ring1.clone(); ring2.rotation.x = Math.PI/2;
            const shell = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6, 0), new THREE.MeshBasicMaterial({color:0x00f0ff, wireframe:true, transparent:true, opacity:0.3}));
            g.add(core); g.add(ring1); g.add(ring2); g.add(shell); g.add(new THREE.PointLight(0x00f0ff, 2, 10));
            scene.add(g);
            aiDrone = { mesh: g, ring1, ring2, shell, core };
        }

        function updateAI(dt) {
            if(!aiDrone.mesh) return;
            const t = yawObject.position.clone().add(new THREE.Vector3(1.5, 0.5, -2).applyQuaternion(yawObject.quaternion));
            aiDrone.mesh.position.lerp(t, 0.05);
            aiDrone.ring1.rotation.y += dt * 2; aiDrone.ring2.rotation.x += dt * 2; aiDrone.shell.rotation.z -= dt * 0.5;
            aiDrone.core.material.emissiveIntensity = 1.5 + Math.sin(Date.now() * 0.005) * 0.5;
            
            if(chatTarget) {
                chatTargetTimer -= dt;
                const dist = chatTarget.position.distanceTo(yawObject.position);
                if(chatTargetTimer <= 0 || dist > 20) setChatTarget(null);
            }
        }

        async function processCommand(cmd) {
            if (chatTarget) {
                addLog(`(å¯¹å¸‚æ°‘ #${chatTarget.userData.id}): ${cmd}`, true);
                showBubble(playerBody, cmd, 'user');
                setTimeout(() => {
                    let reply = "";
                    if(apiKey) {
                        fetchAIResponse(cmd, `ä½ æ˜¯ä¸€ä¸ªèµ›åšæœ‹å…‹ä¸–ç•Œçš„æ™®é€šå¸‚æ°‘ï¼ŒIDä¸º${chatTarget.userData.id}ã€‚è¯·ç”¨ç®€çŸ­çš„å£è¯­å›ç­”è·¯äººï¼š${cmd}`, (text) => npcSpeak(chatTarget, text));
                    } else {
                        const responses = ["å—¯ï¼Ÿä½ è¯´ä»€ä¹ˆï¼Ÿ", "åˆ«çƒ¦æˆ‘ã€‚", "è¿™å¾ˆæœ‰è¶£ã€‚", "æˆ‘ä¹Ÿè§‰å¾—ã€‚", "å°å¿ƒç‚¹ã€‚", "ä½ æ˜¯è°ï¼Ÿ"];
                        reply = responses[Math.floor(Math.random() * responses.length)];
                        npcSpeak(chatTarget, reply);
                    }
                }, 1000);
                return;
            }

            addLog(cmd, true); 
            const lowerCmd = cmd.toLowerCase();
            
            if(lowerCmd.includes('è½¦')) { switchVehicle('car'); return; }
            if(lowerCmd.includes('é£')) { switchVehicle('plane'); return; }
            if(lowerCmd.includes('èµ°')) { switchVehicle('walk'); return; }
            if(lowerCmd.includes('ä¸‹é›¨')) { weatherParticles.visible = true; aiSpeak("ç¯å¢ƒæ¨¡æ‹Ÿï¼šé™é›¨"); return; }

            if(apiKey) {
                fetchAIResponse(cmd, `ä½ æ˜¯ä¸€ä¸ªèµ›åšæœ‹å…‹ä¸–ç•Œçš„æˆ˜æœ¯AIåŠ©æ‰‹ï¼Œåå­—å«ECHOã€‚è¯·ç”¨ç®€çŸ­ã€å†·é…·ã€ç§‘æŠ€æ„Ÿçš„è¯­æ°”å›ç­”æ“ä½œå‘˜çš„è¯ï¼š${cmd}`, (text) => aiSpeak(text));
            } else {
                let reply = localKnowledge["default"][Math.floor(Math.random()*4)];
                for(let k in localKnowledge) if(cmd.includes(k)) reply = localKnowledge[k];
                aiSpeak(reply);
            }
        }

        async function fetchAIResponse(userText, promptText, callback) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
                });
                const data = await response.json();
                if(data.candidates && data.candidates[0].content) {
                    callback(data.candidates[0].content.parts[0].text);
                } else {
                    callback("æ•°æ®æµå¹²æ‰°ã€‚");
                }
            } catch(e) { console.error(e); callback("è¿æ¥ä¸­æ–­ã€‚"); }
        }

        function aiSpeak(text) {
            addLog(text, false);
            showBubble(aiDrone.mesh, text, 'ai');
            sfx.playChatBlip(true);
        }

        function npcSpeak(npc, text) {
            showBubble(npc, text, 'npc');
            sfx.playChatBlip(false);
            if(Math.random() > 0.7) {
                setTimeout(() => aiSpeak(`åˆ†æå¯¹è±¡æƒ…ç»ª: ${["å¹³é™","æ¿€åŠ¨","å›°æƒ‘"][Math.floor(Math.random()*3)]}`), 2000);
            }
        }

        function showBubble(obj, text, type) {
            if(!obj) return;
            const b = document.createElement('div'); b.className = `chat-bubble ${type}`; b.innerText = text;
            ui.bubbles.appendChild(b);
            const heightOffset = type === 'user' ? 2.0 : ((obj.userData && obj.userData.height)||0.5)+0.5;
            let targetObj = obj;
            if (type === 'user') targetObj = { position: new THREE.Vector3(playerBody.position.x, playerBody.position.y, playerBody.position.z), userData: {height: 1.7} };
            activeBubbles.push({ dom: b, obj: targetObj, life: 4.0, offset: heightOffset });
            requestAnimationFrame(()=>b.style.opacity='1');
        }

        function updateBubbles(dt) {
            for(let i=activeBubbles.length-1; i>=0; i--) {
                const b = activeBubbles[i]; b.life-=dt;
                if(b.life<=0) { b.dom.style.opacity='0'; setTimeout(()=>b.dom.remove(),300); activeBubbles.splice(i,1); continue; }
                let pos;
                if(b.obj.position instanceof THREE.Vector3) pos = b.obj.position.clone(); 
                else pos = new THREE.Vector3(b.obj.position.x, b.obj.position.y, b.obj.position.z);
                pos.add(new THREE.Vector3(0, b.offset, 0));
                pos.project(camera);
                const x = (pos.x * .5 + .5) * window.innerWidth;
                const y = (-(pos.y * .5) + .5) * window.innerHeight;
                if(pos.z>1 || Math.abs(pos.x)>1.1 || Math.abs(pos.y)>1.1) b.dom.style.display='none';
                else { b.dom.style.display='block'; b.dom.style.left=`${x}px`; b.dom.style.top=`${y}px`; }
            }
        }

        function initThree() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050510); 
            fog = new THREE.FogExp2(0x050510, 0.002); scene.fog = fog;
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 4000);
            pitchObject = new THREE.Object3D(); pitchObject.add(camera);
            yawObject = new THREE.Object3D(); yawObject.position.y = 2; yawObject.add(pitchObject);
            scene.add(yawObject);
            renderer = new THREE.WebGLRenderer({antialias:false}); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }
        function initPhysics() {
            world = new CANNON.World(); world.gravity.set(0,-20,0);
            const m = new CANNON.Material(); world.addContactMaterial(new CANNON.ContactMaterial(m,m,{friction:0.1, restitution:0}));
            playerBody = new CANNON.Body({mass:60, material:m, fixedRotation:true, linearDamping:0.1});
            playerBody.addShape(new CANNON.Sphere(1)); playerBody.position.set(0, 10, 0); world.addBody(playerBody);
        }
        
        // --- ğŸ® æ ¸å¿ƒæ§åˆ¶é€»è¾‘å®Œç¾ä¿®å¤ ---
        function updatePlayer(dt) {
            const s = vehicleSettings[currentVehicle];
            const maxSpeed = touchState.isSprinting ? s.speed * 2 : s.speed;
            const input = touchState.moveVector;
            const isMoving = Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1;

            // ç‰©ç†å±æ€§æ›´æ–°
            playerBody.linearDamping = s.damping;
            world.gravity.set(0, s.gravity, 0);

            if (isMoving && currentVehicle === 'walk') {
                sfx.playFootstep(touchState.isSprinting ? 0.3 : 0.5);
            }

            if (isMoving) {
                // å®Œç¾æ–¹å‘æ ¡å‡†ï¼šåŸºäºç›¸æœºæœå‘è®¡ç®—ç§»åŠ¨å‘é‡
                const yaw = yawObject.rotation.y;
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);

                // input.x (å·¦å³), input.y (ä¸Šä¸‹ï¼Œä¸Šæ˜¯è´Ÿ)
                // å‰è¿›æ–¹å‘ (-Z in ThreeJS) æ˜¯ ( -sin(yaw), 0, -cos(yaw) )
                // å³ä¾§æ–¹å‘ (+X in ThreeJS) æ˜¯ ( cos(yaw), 0, -sin(yaw) )
                
                // æ··åˆå‘é‡
                // Forward term: push UP (input.y < 0) -> move Forward
                const fwdScale = -input.y; 
                // Right term: push RIGHT (input.x > 0) -> move Right
                const rightScale = input.x;

                const moveX = (rightScale * cosYaw) + (fwdScale * -sinYaw);
                const moveZ = (rightScale * -sinYaw) + (fwdScale * -cosYaw);

                const currentSpeed = input.length() * maxSpeed;
                
                // åº”ç”¨é€Ÿåº¦
                playerBody.velocity.x = moveX * currentSpeed;
                playerBody.velocity.z = moveZ * currentSpeed;

                // é£è¡Œé€»è¾‘
                if (s.fly) {
                    // é£è¡Œæ—¶å…è®¸å¾®è°ƒé«˜åº¦
                    if(touchState.isSprinting) playerBody.velocity.y = 15;
                    else if(Math.abs(input.length())<0.1) playerBody.velocity.y *= 0.9;
                }
            } else {
                playerBody.velocity.x *= (1 - s.damping); 
                playerBody.velocity.z *= (1 - s.damping);
                if(s.fly) playerBody.velocity.y *= 0.95; // æ‚¬æµ®é˜»åŠ›
            }
            
            // è§†è§’å¹³æ»‘è·Ÿéš
            // å¦‚æœæ˜¯è½¦ï¼Œè§†è§’ä½ä¸€ç‚¹ï¼›å¦‚æœæ˜¯é£æœºï¼Œè§†è§’é«˜ä¸€ç‚¹
            const targetY = playerBody.position.y + s.height;
            yawObject.position.x = playerBody.position.x;
            yawObject.position.z = playerBody.position.z;
            yawObject.position.y = THREE.MathUtils.lerp(yawObject.position.y, targetY, 0.1);
            
            // ç›¸æœºå‰åè·ç¦»åç§» (Cam Dist)
            if(s.camDist > 0) {
                 // ç®€å•å®ç°ï¼šå°†ç›¸æœºèŠ‚ç‚¹å¾€åç§»
                 // æ³¨æ„ï¼špitchObject æ˜¯ç›¸æœºçš„çˆ¶èŠ‚ç‚¹ï¼Œå¯ä»¥è°ƒæ•´å…¶ z å€¼
                 camera.position.z = THREE.MathUtils.lerp(camera.position.z, s.camDist, 0.05);
                 camera.position.y = THREE.MathUtils.lerp(camera.position.y, s.camHeight, 0.05);
            } else {
                 camera.position.z = THREE.MathUtils.lerp(camera.position.z, 0, 0.1);
                 camera.position.y = THREE.MathUtils.lerp(camera.position.y, 0, 0.1);
            }

            ui.speed.innerText = Math.round(Math.sqrt(playerBody.velocity.x**2 + playerBody.velocity.z**2));
            checkInteraction();
        }

        function setChatTarget(npc) {
            chatTarget = npc;
            if(npc) {
                chatTargetTimer = 20; 
                ui.targetInd.style.display = 'block';
                ui.targetId.innerText = npc.userData.id;
                ui.input.placeholder = `ä¸ å¸‚æ°‘ #${npc.userData.id} äº¤è°ˆ...`;
            } else {
                ui.targetInd.style.display = 'none';
                ui.input.placeholder = "è¾“å…¥æŒ‡ä»¤/èŠå¤©...";
            }
        }

        function checkInteraction() {
            if(renderer.info.render.frame % 10 !== 0) return;
            const rs = yawObject.position.clone(); const rd = new THREE.Vector3(0,0,-1).applyQuaternion(pitchObject.getWorldQuaternion(new THREE.Quaternion()));
            raycaster.set(rs, rd);
            const hits = raycaster.intersectObjects(interactables, true);
            const btn = document.getElementById('btn-interact');
            
            if(hits.length > 0 && hits[0].distance < 15) {
                let t = hits[0].object; while(t.parent && !t.userData.isNPC) t = t.parent;
                if(t.userData.isNPC) { 
                    btn.style.display = 'flex'; 
                    window.currentInteractionTarget = t; 
                    ui.prompt.style.display='block'; 
                    return; 
                }
            }
            btn.style.display = 'none'; ui.prompt.style.display='none'; window.currentInteractionTarget = null;
        }

        function switchVehicle(type) {
            if(currentVehicle === type) return; 
            currentVehicle = type; 
            const s = vehicleSettings[type];
            ui.modeIcon.innerText = s.icon; 
            ui.modeText.innerText = s.name;
            
            ui.btnWalk.style.display = (type === 'walk') ? 'none' : 'flex';
            
            if(type === 'fly') {
                playerBody.velocity.y = 50; // èµ·é£
                sfx.playRocketLaunch();
                aiSpeak("åé‡åŠ›å¼•æ“å¯åŠ¨ã€‚");
                ui.btnJump.innerText = "ğŸš€"; // å˜ä¸ºä¸Šå‡é”®
            } else if (type === 'car') {
                sfx.playEngineStart();
                aiSpeak("èµ›è½¦æ¨¡å¼å·²æ¿€æ´»ã€‚");
                ui.btnJump.innerText = "ğŸ†™"; // æ¢å¤è·³è·ƒ
            } else {
                aiSpeak("åˆ‡æ¢è‡³æ­¥è¡Œæ¨¡å¼ã€‚");
                ui.btnJump.innerText = "ğŸ†™";
            }
        }

        function setupControls() {
            const joyZone = document.getElementById('joystick-zone');
            const joyBase = document.createElement('div'); joyBase.className = 'joystick-base';
            const joyStick = document.createElement('div'); joyStick.className = 'joystick-stick';
            joyBase.appendChild(joyStick); joyZone.appendChild(joyBase);
            let joyId = null; const joyStart = {x:0, y:0}; const maxR = 60;
            
            // æ‘‡æ†é€»è¾‘
            const handleJoyStart = (x, y, id) => {
                sfx.resume();
                if(joyId!==null) return;
                joyId = id;
                const rect = joyZone.getBoundingClientRect(); 
                joyStart.x = x - rect.left; 
                joyStart.y = y - rect.top;
                joyBase.style.left = joyStart.x+'px'; joyBase.style.top = joyStart.y+'px'; joyBase.style.opacity=1;
            };
            const handleJoyMove = (x, y, id) => {
                if(id !== joyId) return;
                const rect = joyZone.getBoundingClientRect();
                const dx = (x - rect.left) - joyStart.x; const dy = (y - rect.top) - joyStart.y;
                const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxR); const angle = Math.atan2(dy, dx);
                joyStick.style.transform = `translate(-50%,-50%) translate(${Math.cos(angle)*dist}px,${Math.sin(angle)*dist}px)`;
                touchState.moveVector.set(dx, dy).normalize().multiplyScalar(dist/maxR);
                touchState.isSprinting = (dist/maxR) > 0.9;
                joyStick.style.backgroundColor = touchState.isSprinting ? '#ff3366' : 'rgba(0,240,255,0.8)';
            };
            const handleJoyEnd = (id) => {
                if(id === joyId) { 
                    joyId=null; joyBase.style.opacity=0.3; 
                    joyStick.style.transform='translate(-50%,-50%)'; 
                    touchState.moveVector.set(0,0); 
                }
            };

            // Touch Events (Mobile)
            joyZone.addEventListener('touchstart', e => { e.preventDefault(); handleJoyStart(e.changedTouches[0].clientX, e.changedTouches[0].clientY, e.changedTouches[0].identifier); }, {passive:false});
            joyZone.addEventListener('touchmove', e => { e.preventDefault(); for(let t of e.changedTouches) handleJoyMove(t.clientX, t.clientY, t.identifier); }, {passive:false});
            joyZone.addEventListener('touchend', e => { e.preventDefault(); for(let t of e.changedTouches) handleJoyEnd(t.identifier); }, {passive:false});

            // Mouse Events (PC)
            joyZone.addEventListener('mousedown', e => { e.preventDefault(); handleJoyStart(e.clientX, e.clientY, 999); });
            window.addEventListener('mousemove', e => { if(joyId===999) handleJoyMove(e.clientX, e.clientY, 999); });
            window.addEventListener('mouseup', e => { if(joyId===999) handleJoyEnd(999); });


            // Camera Control
            const camZone = document.getElementById('camera-zone'); let camId = null; let lastX=0, lastY=0;
            const handleCamStart = (x, y, id) => { camId=id; lastX=x; lastY=y; };
            const handleCamMove = (x, y, id) => {
                if(id !== camId) return;
                const dx = x-lastX; const dy = y-lastY;
                yawObject.rotation.y -= dx*0.005; pitchObject.rotation.x = Math.max(-1.5, Math.min(1.5, pitchObject.rotation.x - dy*0.005));
                lastX=x; lastY=y;
            };
            camZone.addEventListener('touchstart', e=>{ e.preventDefault(); handleCamStart(e.changedTouches[0].clientX, e.changedTouches[0].clientY, e.changedTouches[0].identifier); }, {passive:false});
            camZone.addEventListener('touchmove', e=>{ e.preventDefault(); for(let t of e.changedTouches) handleCamMove(t.clientX, t.clientY, t.identifier); }, {passive:false});
            camZone.addEventListener('touchend', e=>{ for(let t of e.changedTouches) if(t.identifier===camId) camId=null; });
            camZone.addEventListener('mousedown', e=>{ e.preventDefault(); handleCamStart(e.clientX, e.clientY, 888); });
            window.addEventListener('mousemove', e=>{ if(camId===888) handleCamMove(e.clientX, e.clientY, 888); });
            window.addEventListener('mouseup', e=>{ if(camId===888) camId=null; });

            // Buttons: Force binding both touch and click for reliability
            function bindBtn(id, callback) {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); sfx.resume(); callback(); el.style.transform = 'scale(0.8)'; setTimeout(()=>el.style.transform='scale(1)', 100); }, {passive:false});
                el.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); sfx.resume(); callback(); el.style.transform = 'scale(0.8)'; setTimeout(()=>el.style.transform='scale(1)', 100); });
            }

            bindBtn('btn-car', () => switchVehicle('car'));
            bindBtn('btn-fly', () => switchVehicle('plane'));
            bindBtn('btn-walk', () => switchVehicle('walk'));
            
            // è·³è·ƒ/ä¸Šå‡é”®
            bindBtn('btn-jump', () => {
                if(currentVehicle === 'plane') {
                    playerBody.velocity.y = 20; // é£è¡Œæ¨¡å¼ï¼šä¸Šå‡
                    aiSpeak("çˆ¬å‡ä¸­...");
                } else {
                    if(playerBody.position.y < (getTerrainHeight(playerBody.position.x, playerBody.position.z) + 5)) {
                        playerBody.velocity.y = 15; // èµ°è·¯/å¼€è½¦ï¼šè·³è·ƒ
                    }
                }
            });

            bindBtn('btn-interact', () => { 
                sfx.playInteract();
                if(window.currentInteractionTarget) {
                    setChatTarget(window.currentInteractionTarget);
                    const greeting = ["ä½ å¥½ï¼","ä»Šå¤©å¤©æ°”ä¸é”™ã€‚","æˆ‘åœ¨ç­‰è½¦ã€‚", "ä½ çœ‹ä¸Šå»å¾ˆä¸“ä¸šã€‚", "åˆ«æŒ¡é“ã€‚", "èµ›åšç©ºé—´è§ã€‚"][Math.floor(Math.random()*6)];
                    npcSpeak(window.currentInteractionTarget, greeting);
                } 
            });
            ui.input.addEventListener('keydown', e=>{ if(e.key==='Enter') { processCommand(ui.input.value); ui.input.value=''; } });
            
            // Global Audio Wakeup
            document.body.addEventListener('touchstart', () => sfx.resume(), {once:true});
            document.body.addEventListener('click', () => sfx.resume(), {once:true});
        }

        function updateEnvironment(dt) {
            dayTime=(dayTime+dt*0.001)%1; const phi=dayTime*Math.PI*2;
            sunLight.position.set(Math.sin(phi)*800, Math.cos(phi)*800, 200); sunMesh.position.copy(sunLight.position);
            const isNight = dayTime<0.25||dayTime>0.75;
            const sky = new THREE.Color(isNight?0x050510:0xffaa55);
            scene.background.lerp(sky, 0.05); fog.color.lerp(sky, 0.05); sunLight.intensity = isNight?0:1.2;
            buildingMaterials.forEach(m=>m.emissiveIntensity=THREE.MathUtils.lerp(m.emissiveIntensity, isNight?1:0, 0.05));
            ui.time.innerText = `${Math.floor(dayTime*24).toString().padStart(2,'0')}:${Math.floor((dayTime*24*60)%60).toString().padStart(2,'0')}`;
        }

        // --- ğŸš¶ çœŸå® NPC ç³»ç»Ÿ ---
        function initRealNPCs(count) {
            const colors = [0xAA3333, 0x33AA33, 0x3333AA, 0xAAAA33, 0x33AAAA, 0xAA33AA, 0xFFFFFF, 0x333333];
            
            for(let i=0; i<count; i++) {
                const group = new THREE.Group();
                const skinColor = 0xffccaa;
                const shirtColor = colors[Math.floor(Math.random()*colors.length)];
                const pantsColor = 0x222222;

                const headGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const bodyGeo = new THREE.BoxGeometry(0.4, 0.5, 0.25);
                const limbGeo = new THREE.BoxGeometry(0.12, 0.5, 0.12);

                const skinMat = new THREE.MeshStandardMaterial({color: skinColor});
                const shirtMat = new THREE.MeshStandardMaterial({color: shirtColor});
                const pantsMat = new THREE.MeshStandardMaterial({color: pantsColor});

                const head = new THREE.Mesh(headGeo, skinMat); head.position.y = 1.65;
                const body = new THREE.Mesh(bodyGeo, shirtMat); body.position.y = 1.25;
                
                const armL = new THREE.Mesh(limbGeo, shirtMat); armL.position.set(-0.28, 1.25, 0); 
                const armR = new THREE.Mesh(limbGeo, shirtMat); armR.position.set(0.28, 1.25, 0);
                
                const legL = new THREE.Mesh(limbGeo, pantsMat); legL.position.set(-0.12, 0.75, 0);
                const legR = new THREE.Mesh(limbGeo, pantsMat); legR.position.set(0.12, 0.75, 0);

                function createLimb(mesh, yPivot) {
                    const g = new THREE.Group(); g.position.set(mesh.position.x, mesh.position.y + yPivot, mesh.position.z);
                    mesh.position.set(0, -yPivot, 0); 
                    g.add(mesh);
                    return g;
                }

                const gArmL = createLimb(armL, 0.2); 
                const gArmR = createLimb(armR, 0.2);
                const gLegL = createLimb(legL, 0.25);
                const gLegR = createLimb(legR, 0.25);

                group.add(head); group.add(body);
                group.add(gArmL); group.add(gArmR);
                group.add(gLegL); group.add(gLegR);

                group.position.set((Math.random()-0.5)*300, 0, (Math.random()-0.5)*300);
                group.userData = { 
                    isNPC: true, height: 1.8, id: Math.floor(Math.random()*9000)+1000, 
                    lastTalkTime: 0, lastGreetingTime: 0,
                    limbs: { gArmL, gArmR, gLegL, gLegR },
                    isStopped: false 
                };
                
                scene.add(group); 
                interactables.push(group); 
                npcs.push({ mesh: group, dir: Math.random()*6, speed: 1.5 + Math.random(), timer: 0 });
            }
        }

        function updateNPCs(dt) {
            const now = Date.now();
            npcs.forEach((n, idx) => {
                // --- ç¤¾äº¤è·ç¦»æ£€æµ‹ ---
                const distToPlayer = n.mesh.position.distanceTo(playerBody.position);
                const isClose = distToPlayer < 8; // 8ç±³å†…è§¦å‘

                if (isClose) {
                    // 1. åœä¸‹æ¥
                    n.mesh.userData.isStopped = true;

                    // 2. è½¬èº«é¢å‘ç©å®¶
                    const targetPos = new THREE.Vector3(playerBody.position.x, n.mesh.position.y, playerBody.position.z);
                    n.mesh.lookAt(targetPos);

                    // 3. ä¸»åŠ¨æ­è®ª (æƒ…å¢ƒæ„ŸçŸ¥)
                    if (now - n.mesh.userData.lastGreetingTime > 15000) { // 15ç§’å†·å´
                        const category = currentVehicle; // walk, car, plane
                        const phrases = smartGreetings[category] || smartGreetings['walk'];
                        const text = phrases[Math.floor(Math.random() * phrases.length)];
                        
                        npcSpeak(n.mesh, text);
                        n.mesh.userData.lastGreetingTime = now;
                        
                        // è‡ªåŠ¨è®¾ä¸ºå½“å‰äº¤äº’ç›®æ ‡
                        if(!chatTarget) setChatTarget(n.mesh);
                    }
                } else {
                    // è¿œç¦»åæ¢å¤è¡Œèµ°
                    n.mesh.userData.isStopped = false;
                }

                // --- ç§»åŠ¨é€»è¾‘ (ä»…å½“æœªåœä¸‹æ—¶) ---
                if (!n.mesh.userData.isStopped) {
                    n.timer += dt; 
                    if(n.timer > 3) { if(Math.random()>0.5) n.dir += (Math.random()-0.5)*2; n.timer=0; }
                    
                    const dx = Math.sin(n.dir) * n.speed * dt;
                    const dz = Math.cos(n.dir) * n.speed * dt;
                    n.mesh.position.x += dx; 
                    n.mesh.position.z += dz; 
                    n.mesh.rotation.y = n.dir;

                    const h = getTerrainHeight(n.mesh.position.x, n.mesh.position.z);
                    n.mesh.position.y = h;

                    // èµ°è·¯åŠ¨ç”»
                    const timeScale = now * 0.005 * n.speed;
                    const limbs = n.mesh.userData.limbs;
                    limbs.gLegL.rotation.x = Math.sin(timeScale) * 0.6;
                    limbs.gLegR.rotation.x = Math.sin(timeScale + Math.PI) * 0.6;
                    limbs.gArmL.rotation.x = Math.sin(timeScale + Math.PI) * 0.6; 
                    limbs.gArmR.rotation.x = Math.sin(timeScale) * 0.6;
                } else {
                    // ç«™ç«‹åŠ¨ç”» (å‘¼å¸)
                    const limbs = n.mesh.userData.limbs;
                    limbs.gLegL.rotation.x = THREE.MathUtils.lerp(limbs.gLegL.rotation.x, 0, 0.1);
                    limbs.gLegR.rotation.x = THREE.MathUtils.lerp(limbs.gLegR.rotation.x, 0, 0.1);
                    limbs.gArmL.rotation.x = THREE.MathUtils.lerp(limbs.gArmL.rotation.x, 0, 0.1);
                    limbs.gArmR.rotation.x = THREE.MathUtils.lerp(limbs.gArmR.rotation.x, 0, 0.1);
                }

                // --- NPC é—´äº’èŠé€»è¾‘ ---
                if (idx % 5 === 0 && now - n.mesh.userData.lastTalkTime > 8000 && !isClose) { 
                    for (let other of npcs) {
                        if (other === n) continue;
                        if (n.mesh.position.distanceToSquared(other.mesh.position) < 25) { 
                             if (now - other.mesh.userData.lastTalkTime > 8000) {
                                const talk = npcDialogues[Math.floor(Math.random() * npcDialogues.length)];
                                npcSpeak(n.mesh, talk);
                                n.mesh.userData.lastTalkTime = now;
                                other.mesh.userData.lastTalkTime = now + 2000; 
                                break; 
                             }
                        }
                    }
                }
            });
        }
        
        function addLog(txt, isUser) { const d=document.createElement('div'); d.style.color=isUser?'#fff':'#00f0ff'; d.textContent=(isUser?'> ':'> ECHO: ')+txt; ui.log.appendChild(d); ui.log.scrollTop=ui.log.scrollHeight; }
        function initVoice() { if('webkitSpeechRecognition' in window) { const r=new webkitSpeechRecognition(); r.lang='zh-CN'; const b=document.getElementById('mic-btn'); r.onstart=()=>b.classList.add('listening'); r.onend=()=>b.classList.remove('listening'); r.onresult=e=>processCommand(e.results[0][0].transcript); b.onclick=()=>r.start(); } }

        function animate(time) {
            requestAnimationFrame(animate); const dt=(time-lastTime)/1000||1/60; lastTime=time;
            if(isGameActive) {
                world.step(1/60); updatePlayer(dt); updateAI(dt); updateNPCs(dt); updateTraffic(dt); updateEnvironment(dt); updateBubbles(dt);
                spatialAudio.update(playerBody.position, cars);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
