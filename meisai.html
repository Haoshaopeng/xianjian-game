<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>VIVID WORLD: SOCIAL CONNECT</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€ --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top:0; left:0; z-index: 1; }
        
        /* --- HUD --- */
        #hud-layer {
            position: absolute; top: 10px; left: 10px;
            color: #fff; font-family: 'Consolas', monospace; z-index: 20; pointer-events: none;
            background: linear-gradient(90deg, rgba(0,0,0,0.8), transparent);
            padding: 10px; border-left: 3px solid #00f0ff;
            text-shadow: 0 0 5px rgba(0, 240, 255, 0.8);
            transform: scale(0.8); transform-origin: top left;
        }
        .hud-item { margin-bottom: 5px; font-size: 16px; display: flex; align-items: center; }
        .vehicle-icon { font-size: 20px; margin-right: 10px; width: 25px; text-align: center; }
        .status-ok { color: #00ff00; }
        .status-busy { color: #ffaa00; }

        /* --- åŠ¨æ€æ°”æ³¡ --- */
        .chat-bubble {
            position: absolute; background: rgba(0, 20, 30, 0.9); border: 1px solid #00f0ff; color: #00f0ff;
            padding: 8px 12px; border-radius: 8px; font-size: 12px; pointer-events: none; max-width: 180px;
            transform: translate(-50%, -100%); margin-top: -20px; opacity: 0; transition: opacity 0.3s; z-index: 15;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.2); text-align: center; white-space: pre-wrap;
        }
        .chat-bubble::after {
            content: ''; position: absolute; bottom: -6px; left: 50%; margin-left: -6px;
            border-width: 6px 6px 0; border-style: solid; border-color: #00f0ff transparent transparent transparent;
        }
        .chat-bubble.npc { border-color: #ffaa00; color: #ffaa00; box-shadow: 0 0 10px rgba(255, 170, 0, 0.3); z-index: 14; }
        .chat-bubble.npc::after { border-color: #ffaa00 transparent transparent transparent; }
        
        .chat-bubble.user { border-color: #ffffff; color: #ffffff; box-shadow: 0 0 10px rgba(255, 255, 255, 0.3); z-index: 16; }
        .chat-bubble.user::after { border-color: #ffffff transparent transparent transparent; }

        /* --- ç§»åŠ¨ç«¯æ§åˆ¶å™¨ --- */
        .control-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 30; pointer-events: none; }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 180px; height: 180px; pointer-events: auto; }
        .joystick-base {
            position: absolute; top: 50%; left: 50%; width: 120px; height: 120px; transform: translate(-50%, -50%);
            border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2);
            background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.1) 100%);
            transition: opacity 0.2s;
        }
        .joystick-stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; transform: translate(-50%, -50%);
            border-radius: 50%; background: rgba(0, 240, 255, 0.8); box-shadow: 0 0 15px #00f0ff; pointer-events: none;
        }
        #camera-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; z-index: 29; pointer-events: auto; }
        #action-zone { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 15px; align-items: flex-end; pointer-events: auto; }
        .action-btn {
            width: 65px; height: 65px; border-radius: 50%; background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3); color: #fff; display: flex; justify-content: center; align-items: center;
            font-size: 24px; backdrop-filter: blur(5px); transition: all 0.1s;
        }
        .action-btn:active { transform: scale(0.9); background: rgba(0, 240, 255, 0.4); border-color: #00f0ff; }
        .action-btn.main-action { width: 85px; height: 85px; border-color: #ff3366; background: rgba(40, 10, 20, 0.5); }
        .action-btn.main-action:active { background: #ff3366; }

        /* --- äº¤äº’æç¤º --- */
        #interaction-prompt {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            color: #ffaa00; font-size: 16px; font-weight: bold; display: none; z-index: 25;
            text-shadow: 0 0 10px #ffaa00; pointer-events: none; letter-spacing: 2px;
            background: rgba(0, 0, 0, 0.6); padding: 10px 30px; border: 1px solid #ffaa00; border-radius: 4px;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { opacity: 0.8; box-shadow: 0 0 10px #ffaa00; } to { opacity: 1; box-shadow: 0 0 20px #ffaa00; } }
        
        #target-indicator {
            position: absolute; top: 120px; left: 10px;
            color: #ffaa00; font-family: 'Consolas', monospace; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 5px; border: 1px solid #ffaa00;
            display: none; z-index: 20;
        }

        /* --- æŒ‡ä»¤æ§åˆ¶å° --- */
        #command-interface {
            position: absolute; top: 10px; right: 10px; width: 240px; pointer-events: auto; z-index: 35; display: flex; flex-direction: column; gap: 5px; opacity: 0.9;
        }
        #ai-log {
            background: rgba(0, 20, 30, 0.9); border: 1px solid #00f0ff; padding: 5px; height: 100px;
            overflow-y: auto; color: #ccffff; font-size: 10px; font-family: monospace; scrollbar-width: none;
            display: flex; flex-direction: column; justify-content: flex-end; pointer-events: none;
        }
        .input-group { display: flex; gap: 5px; }
        #command-input {
            flex-grow: 1; background: rgba(0, 0, 0, 0.6); border: 1px solid #00f0ff; color: #fff;
            padding: 5px; outline: none; font-family: monospace; font-size: 12px; border-radius: 4px;
        }
        #mic-btn { background: rgba(0, 40, 50, 0.8); border: 1px solid #00f0ff; color: #00f0ff; width: 30px; cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #mic-btn.listening { background: #00f0ff; color: #000; }

        /* --- é®ç½©å±‚ (Keyè¾“å…¥) --- */
        #blocker {
            position: absolute; width: 100%; height: 100%; background: #000;
            display: flex; align-items: center; justify-content: center; z-index: 100;
            flex-direction: column; 
        }
        #instructions {
            color: #fff; text-align: center; padding: 20px; width: 80%; max-width: 400px;
            border: 1px solid #00f0ff; background: rgba(0, 20, 30, 0.95);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.3); border-radius: 10px;
        }
        .api-input {
            width: 90%; padding: 10px; margin: 15px 0; background: rgba(0,0,0,0.5); 
            border: 1px solid #333; color: #fff; border-radius: 4px; font-family: monospace;
        }
        .start-btn {
            background: #00f0ff; color: #000; border: none; padding: 10px 30px; 
            font-weight: bold; cursor: pointer; border-radius: 4px; font-size: 16px;
        }
        h1 { color: #00f0ff; margin: 0 0 20px 0; font-size: 24px; letter-spacing: 2px; }
        .rotate-hint { display: none; color: #ff3366; font-size: 20px; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 200; justify-content: center; align-items: center; text-align: center; }
        @media screen and (orientation: portrait) { .rotate-hint { display: flex; } #blocker, #hud-layer, #command-interface { display: none; } }
    </style>
</head>
<body>

    <div class="rotate-hint">
        <div>âš ï¸ è¯·æ—‹è½¬æ‰‹æœºè‡³æ¨ªå± âš ï¸</div>
    </div>

    <div id="canvas-container"></div>
    <div id="bubble-container"></div>

    <div id="hud-layer">
        <div class="hud-item"><span id="mode-icon" class="vehicle-icon">ğŸƒ</span><span id="mode-text">æ­¥è¡Œ</span></div>
        <div class="hud-item"><span class="vehicle-icon">âŒš</span><span id="time-text">12:00</span></div>
        <div class="hud-item"><span class="vehicle-icon">âš¡</span><span id="speed-text">0</span> km/h</div>
        <div class="hud-item"><span class="vehicle-icon">ğŸ§ </span>AI: <span id="ai-status" class="status-ok">ç¦»çº¿</span></div>
    </div>

    <div id="target-indicator">å½“å‰é€šè¯å¯¹è±¡: å¸‚æ°‘ #<span id="target-id">--</span></div>
    <div id="interaction-prompt">ğŸ‘‹ ç‚¹å‡»äº¤è°ˆ</div>

    <div class="control-layer">
        <div id="joystick-zone"></div>
        <div id="camera-zone"></div>
        <div id="action-zone">
            <div class="action-btn" id="btn-interact" style="display:none;">ğŸ’¬</div>
            <div class="action-btn" id="btn-car">ğŸï¸</div>
            <div class="action-btn main-action" id="btn-jump">ğŸš€</div>
        </div>
    </div>

    <div id="command-interface">
        <div id="ai-log">
            <div style="color: #888;">> ç³»ç»Ÿåˆå§‹åŒ–...</div>
        </div>
        <div class="input-group">
            <input type="text" id="command-input" placeholder="è¾“å…¥æŒ‡ä»¤/èŠå¤©..." autocomplete="off">
            <button id="mic-btn">ğŸ¤</button>
        </div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <h1>NEURAL LINK // V3.2 SOCIAL</h1>
            <p style="font-size:12px; color:#aaa;">æ¥å…¥ Gemini çŸ©é˜µä»¥æ¿€æ´»å®Œå…¨æ™ºèƒ½</p>
            <div style="height: 1px; background: #005566; margin: 15px 0;"></div>
            
            <input type="password" id="api-key-input" class="api-input" placeholder="è¾“å…¥ Google API Key (å¯é€‰)">
            <p style="font-size: 10px; color: #666; margin-top:-10px; margin-bottom: 20px;">*ç•™ç©ºåˆ™ä½¿ç”¨æœ¬åœ°æ¨¡æ‹Ÿæ¨¡å¼ (æ”¯æŒåŸºæœ¬å¯¹è¯)</p>
            
            <button class="start-btn" id="start-game-btn">æ¥å…¥ç³»ç»Ÿ</button>
            
            <p style="font-size: 12px; color: #666; margin-top: 15px;">å…¨åŸæ¼«æ¸¸ Â· ç©ºé—´éŸ³é¢‘ Â· æ™ºèƒ½ç¤¾äº¤</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- ç³»ç»Ÿå˜é‡ ---
        let camera, scene, renderer, world, playerBody;
        let isGameActive = false;
        let lastTime = 0;
        let yawObject, pitchObject;
        let apiKey = ""; 
        let chatTarget = null; // null = AI, object = NPC
        let chatTargetTimer = 0;
        
        // --- æ¸¸æˆçŠ¶æ€ ---
        let time = 0, dayTime = 0.45;
        const touchState = { moveVector: new THREE.Vector2(0, 0), isSprinting: false };
        let currentVehicle = 'walk';
        const vehicleSettings = {
            walk: { speed: 12, jump: 8, height: 1.7, fly: false, damping: 0.1, icon: 'ğŸƒ', name: 'æ­¥è¡Œ' },
            car:  { speed: 50, jump: 2, height: 1.2, fly: false, damping: 0.2, icon: 'ğŸï¸', name: 'è·‘è½¦' },
            plane: { speed: 120, jump: 20, height: 5.0, fly: true, damping: 0.5, icon: 'âœˆï¸', name: 'æˆ˜æœº' }
        };

        // --- èµ„æºä¸å¯¹è±¡ ---
        const visualMeshes = [], interactables = [], cars = [], npcs = [];
        let buildingMaterials = [];
        let terrainMesh, waterMesh, terrainBody;
        let roadTexture, crosswalkTexture, windowTexture, lightPoolTexture;
        let roadData = []; 
        let sunLight, ambientLight, sunMesh, fog, weatherParticles;
        let aiDrone = { mesh: null, ring1: null, ring2: null, core: null };
        const activeBubbles = [];
        const ui = {};
        let raycaster = new THREE.Raycaster();

        // --- ğŸ”Š å¢å¼ºéŸ³æ•ˆå¼•æ“ ---
        class SoundFX {
            constructor() {
                this.ctx = null;
                this.footstepTimer = 0;
                this.masterGain = null;
                this.carSources = [];
            }
            init() {
                if (this.ctx) return;
                try {
                    const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC();
                    this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = 0.4;
                    this.masterGain.connect(this.ctx.destination);
                } catch(e) { console.warn("Audio init failed", e); }
            }
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }
            
            playTone(freq, type, duration, vol=0.1, when=0) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator(); osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime + when);
                const g = this.ctx.createGain(); g.gain.setValueAtTime(vol, this.ctx.currentTime + when);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + when + duration);
                osc.connect(g); g.connect(this.masterGain);
                osc.start(this.ctx.currentTime + when); osc.stop(this.ctx.currentTime + when + duration + 0.1);
            }

            playFootstep(interval) {
                if(!this.ctx || currentVehicle !== 'walk') return;
                if(this.ctx.currentTime > this.footstepTimer) {
                    // æ¨¡æ‹Ÿè„šæ­¥å£°: çŸ­ä¿ƒçš„ä½é¢‘å™ªéŸ³
                    this.playTone(100 + Math.random()*50, 'triangle', 0.05, 0.2);
                    this.footstepTimer = this.ctx.currentTime + interval;
                }
            }

            playChatBlip(isAI) {
                if(!this.ctx) return;
                if(isAI) { // ç§‘æŠ€æ„Ÿ AI å£°éŸ³
                    this.playTone(800, 'sine', 0.1, 0.1);
                    this.playTone(1200, 'sine', 0.1, 0.1, 0.1);
                } else { // æŸ”å’Œ NPC å£°éŸ³
                    this.playTone(400 + Math.random()*200, 'sine', 0.15, 0.1);
                }
            }

            playInteract() { this.playTone(600, 'square', 0.1, 0.05); }
        }
        const sfx = new SoundFX();

        // --- ç©ºé—´éŸ³é¢‘ (è½¦è¾†) ---
        class SpatialAudioEngine {
            constructor() { this.carPool = []; this.maxSources = 6; }
            init() {
                if (!sfx.ctx) return;
                for(let i=0; i<this.maxSources; i++) this.carPool.push(this.createCarSource());
            }
            createCarSource() {
                const osc = sfx.ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = 60; osc.start();
                const panner = sfx.ctx.createPanner(); panner.panningModel = 'HRTF'; panner.distanceModel = 'inverse';
                panner.refDistance = 10; panner.maxDistance = 300;
                const gain = sfx.ctx.createGain(); gain.gain.value = 0;
                osc.connect(panner); panner.connect(sfx.masterGain);
                return { osc, panner, gain, active: false };
            }
            update(pos, cars) {
                if(!sfx.ctx) return;
                const L = sfx.ctx.listener;
                if(L.positionX) { L.positionX.value=pos.x; L.positionY.value=pos.y; L.positionZ.value=pos.z; } else L.setPosition(pos.x, pos.y, pos.z);
                cars.forEach(c => c.distSq = c.mesh.position.distanceToSquared(pos)); cars.sort((a,b)=>a.distSq-b.distSq);
                this.carPool.forEach((s, i) => {
                    const c = cars[i];
                    if (c && c.distSq < 250000) {
                        s.gain.gain.setTargetAtTime(0.15, sfx.ctx.currentTime, 0.1);
                        s.panner.setPosition(c.mesh.position.x, c.mesh.position.y, c.mesh.position.z);
                        const freq = THREE.MathUtils.clamp(60 + c.speed * 2, 30, 600);
                        s.osc.frequency.setTargetAtTime(freq, sfx.ctx.currentTime, 0.1);
                    } else s.gain.gain.setTargetAtTime(0, sfx.ctx.currentTime, 0.5);
                });
            }
        }
        const spatialAudio = new SpatialAudioEngine();

        // --- çŸ¥è¯†åº“ & é—²èŠ ---
        const npcDialogues = [
            "å¦‚æœä½ å»å¸‚ä¸­å¿ƒï¼Œè®°å¾—å¸¦ä¼ã€‚", "æœ€è¿‘çš„èŠ¯ç‰‡ä»·æ ¼åˆæ¶¨äº†ã€‚", "å¬è¯´ç¬¬ä¸ƒåŒºæ˜¨æ™šæœ‰éæ³•èµ›è½¦ã€‚", "æˆ‘å¾—èµ¶åœ¨å¤©é»‘å‰å›å®¶ã€‚", 
            "è¿™åŸå¸‚çš„éœ“è™¹ç¯çœ‹ä¹…äº†çœ¼ç›ç–¼ã€‚", "ä½ æ˜¯æ–°æ¥çš„å—ï¼Ÿè£…å¤‡ä¸é”™ã€‚", "åˆ«æŒ¡è·¯ï¼Œæˆ‘åœ¨èµ¶æ—¶é—´ã€‚", "å˜¿ï¼Œåˆšæ‰é‚£è¾†è½¦é£å¾—çœŸä½ï¼",
            "ä½ æœ‰å¤‡ç”¨ç”µæ± å—ï¼Ÿ", "å¤©æ°”é¢„æŠ¥è¯´ä»Šæ™šæœ‰é…¸é›¨ã€‚"
        ];
        
        const localKnowledge = {
            "è°": "æˆ‘æ˜¯ ECHOï¼Œæˆ˜æœ¯è¾…åŠ©å•å…ƒã€‚",
            "ä½ å¥½": "ç³»ç»Ÿåœ¨çº¿ã€‚éšæ—¶å¾…å‘½ã€‚",
            "å¹²ä»€ä¹ˆ": "é©¾é©¶ã€é£è¡Œï¼Œæˆ–ä¸å¸‚æ°‘äº’åŠ¨ã€‚",
            "default": ["æˆ‘åœ¨å¬ã€‚", "ä¿¡å·æ­£å¸¸ã€‚", "è¯·æŒ‡ç¤ºã€‚", "åˆ†æå‘¨å›´ç¯å¢ƒä¸­..."]
        };

        init();

        function init() {
            // UI Binding
            ui.modeIcon = document.getElementById('mode-icon'); ui.modeText = document.getElementById('mode-text');
            ui.time = document.getElementById('time-text'); ui.speed = document.getElementById('speed-text');
            ui.aiStatus = document.getElementById('ai-status'); ui.log = document.getElementById('ai-log');
            ui.input = document.getElementById('command-input'); ui.prompt = document.getElementById('interaction-prompt');
            ui.bubbles = document.getElementById('bubble-container');
            ui.targetInd = document.getElementById('target-indicator');
            ui.targetId = document.getElementById('target-id');

            document.getElementById('start-game-btn').addEventListener('click', startGame);
            
            // Textures & Assets
            createRoadTextures(); createWindowTexture(); createLightPoolTexture();
            
            // 3D & Physics
            initThree(); initPhysics(); initWorld(); initAI_Upgraded();
            
            // Input
            setupControls(); initVoice();
            
            // Loop
            animate();
        }

        function startGame() {
            const keyInput = document.getElementById('api-key-input').value.trim();
            if(keyInput) {
                apiKey = keyInput;
                ui.aiStatus.innerText = "åœ¨çº¿";
                ui.aiStatus.className = "status-ok";
                addLog("Gemini API å·²æ¥å…¥ã€‚ç¤¾äº¤æ¨¡å—åŠ è½½å®Œæ¯•...", false);
            } else {
                addLog("ç¦»çº¿æ¨¡å¼ã€‚å¯ç”¨æœ¬åœ°ç¤¾äº¤æ¨¡æ‹Ÿåè®®ã€‚", false);
            }

            document.getElementById('blocker').style.display = 'none';
            isGameActive = true;
            try { if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(()=>{}); } catch(e){}
            
            sfx.init(); sfx.resume(); spatialAudio.init();
            setTimeout(() => aiSpeak(apiKey ? "ç½‘ç»œè¿æ¥æ­£å¸¸ã€‚æˆ‘æ˜¯ ECHOï¼Œæ‚¨å¯ä»¥ä¸æˆ‘æˆ–è·¯äººäº¤è°ˆã€‚" : "ç¦»çº¿ç³»ç»Ÿå¯åŠ¨ã€‚è·¯äººäº¤äº’åè®®å·²æ¿€æ´»ã€‚"), 1000);
        }

        // --- é€»è¾‘æ•´åˆ: åœºæ™¯ä¸åŸå¸‚ ---
        function initWorld() {
            // ç¯å…‰
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 1.2); sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(1024,1024); sunLight.shadow.camera.top=500; sunLight.shadow.camera.bottom=-500; sunLight.shadow.camera.left=-500; sunLight.shadow.camera.right=500;
            scene.add(sunLight);
            sunMesh = new THREE.Mesh(new THREE.SphereGeometry(30), new THREE.MeshBasicMaterial({color:0xffaa00})); scene.add(sunMesh);

            // å¤©æ°”ç²’å­
            const geo = new THREE.BufferGeometry();
            const pos = []; for(let i=0; i<8000; i++) pos.push((Math.random()-0.5)*1000, Math.random()*200, (Math.random()-0.5)*1000);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            weatherParticles = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xaaaaaa, size: 0.2, transparent: true}));
            weatherParticles.visible = false; scene.add(weatherParticles);

            initTerrain();
            initCity();
            initTraffic(60); 
            initNPCs(50);
        }

        function initTerrain() {
            if(terrainMesh) scene.remove(terrainMesh); if(terrainBody) world.removeBody(terrainBody);
            // åœ°å½¢ç”Ÿæˆé€»è¾‘ (å±±è°·/å¹³åŸ)
            const sz = 2000;
            const geo = new THREE.PlaneGeometry(sz, sz, 64, 64); geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++) pos.setY(i, getTerrainHeight(pos.getX(i), pos.getZ(i))); 
            geo.computeVertexNormals();
            terrainMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x2a3a2a, roughness: 0.9 }));
            terrainMesh.receiveShadow = true; scene.add(terrainMesh);
            
            const matrix = []; const s=32;
            for(let i=0; i<s; i++) { matrix.push([]); for(let j=0; j<s; j++) matrix[i].push(getTerrainHeight((i/(s-1)-0.5)*sz, -(j/(s-1)-0.5)*sz)); }
            terrainBody = new CANNON.Body({ mass: 0 }); 
            terrainBody.addShape(new CANNON.Heightfield(matrix, { elementSize: sz/(s-1) }));
            terrainBody.position.set(-sz/2, 0, sz/2); terrainBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(terrainBody);
        }

        function getTerrainHeight(x, z) {
            let y = Math.sin(x * 0.002) * 15 + Math.cos(z * 0.002) * 15;
            if(Math.abs(z - Math.sin(x*0.005)*50) < 120) y -= 10;
            return y;
        }

        function initCity() {
            visualMeshes.forEach(m=>scene.remove(m)); visualMeshes.length=0; interactables.length=0;
            roadData = [];
            const OVERPASS_Z = -200;

            // 1. é«˜æ¶æ¡¥
            createBridgeSegment(-1000, OVERPASS_Z, 2000, 30, 'x', 30);

            // 2. åœ°é¢è·¯ç½‘
            const gridSpacing = 120, segmentLen = 40;
            for(let z = -800; z <= 800; z += gridSpacing) {
                roadData.push({type:'x', z:z});
                for(let x = -800; x < 800; x += segmentLen) {
                    const cx = x + segmentLen/2;
                    if((Math.abs(x)%gridSpacing < 40) && (Math.abs(z)%gridSpacing === 0)) createIntersection(cx, getTerrainHeight(cx, z)+0.15, z);
                    else createRoadSegment(cx, z, segmentLen, 20, 'x');
                }
            }
            for(let x = -800; x <= 800; x += gridSpacing) {
                roadData.push({type:'z', x:x});
                for(let z = -800; z < 800; z += segmentLen) {
                    const cz = z + segmentLen/2;
                    if(!(Math.abs(z)%gridSpacing < 40)) createRoadSegment(x, cz, segmentLen, 20, 'z');
                }
            }
            createRamp();

            // 4. å»ºç­‘
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            for(let i=0; i<300; i++) {
                const x = (Math.random()-0.5)*1400, z = (Math.random()-0.5)*1400;
                let safe = true;
                for(let r of roadData) if((r.type==='x' && Math.abs(z-r.z)<15) || (r.type==='z' && Math.abs(x-r.x)<15)) safe=false;
                if(!safe || Math.abs(z - OVERPASS_Z) < 30) continue;

                const h = 20+Math.random()*100, w = 10+Math.random()*15, y = getTerrainHeight(x,z);
                const mat = new THREE.MeshStandardMaterial({color: Math.random()*0x888888, roughness: 0.3, emissiveMap: windowTexture, emissive: 0xffffff, emissiveIntensity: 0});
                buildingMaterials.push(mat);
                const mesh = new THREE.Mesh(boxGeo, mat);
                mesh.position.set(x, y+h/2-5, z); mesh.scale.set(w, h, w);
                
                const uv = mesh.geometry.attributes.uv; 
                mesh.castShadow=true; mesh.receiveShadow=true; scene.add(mesh); visualMeshes.push(mesh);
                const body = new CANNON.Body({mass:0}); body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, w/2)), new CANNON.Vec3(x, y+h/2-5, z)); world.addBody(body);
            }
        }

        // --- åŸå¸‚ç»„ä»¶ç”Ÿæˆå™¨ ---
        function createRoadTextures() {
            const c = document.createElement('canvas'); c.width=512; c.height=512; const ctx=c.getContext('2d');
            ctx.fillStyle='#181818'; ctx.fillRect(0,0,512,512); ctx.fillStyle='#fff';
            ctx.fillRect(5,0,8,512); ctx.fillRect(499,0,8,512);
            for(let y=0; y<512; y+=64) ctx.fillRect(254,y+16,4,32);
            roadTexture = new THREE.CanvasTexture(c); roadTexture.wrapS=roadTexture.wrapT=THREE.RepeatWrapping; roadTexture.anisotropy=4;
            
            const c2=document.createElement('canvas'); c2.width=512; c2.height=256; const ctx2=c2.getContext('2d');
            ctx2.fillStyle='#181818'; ctx2.fillRect(0,0,512,256); ctx2.fillStyle='#eee';
            for(let x=25; x<487; x+=40) ctx2.fillRect(x,25,25,206);
            crosswalkTexture = new THREE.CanvasTexture(c2); crosswalkTexture.anisotropy=4;
        }
        function createWindowTexture() {
            const c=document.createElement('canvas'); c.width=256; c.height=256; const ctx=c.getContext('2d');
            ctx.fillStyle='#000'; ctx.fillRect(0,0,256,256);
            for(let y=0; y<256; y+=16) for(let x=0; x<256; x+=8) if(Math.random()>0.9) { ctx.fillStyle=Math.random()>0.8?'#fa5':'#8cf'; ctx.fillRect(x+1,y+1,6,14); }
            windowTexture = new THREE.CanvasTexture(c); windowTexture.wrapS=windowTexture.wrapT=THREE.RepeatWrapping;
        }
        function createLightPoolTexture() {
            const c=document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d');
            const g=ctx.createRadialGradient(32,32,0,32,32,32); g.addColorStop(0,'rgba(255,200,100,0.5)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64); lightPoolTexture = new THREE.CanvasTexture(c);
        }
        function createBridgeSegment(x, z, len, w, axis, y) {
            const geo = new THREE.BoxGeometry(len, 2, w); if(axis==='z') geo.rotateY(Math.PI/2);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0x555555}));
            mesh.position.set(x + (axis==='x'?len/2:0), y, z + (axis==='z'?len/2:0));
            mesh.receiveShadow = true; scene.add(mesh); visualMeshes.push(mesh);
            const body = new CANNON.Body({mass:0});
            body.addShape(new CANNON.Box(new CANNON.Vec3(len/2, 1, w/2)), new CANNON.Vec3(mesh.position.x, y, mesh.position.z));
            if(axis==='z') body.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), Math.PI/2);
            world.addBody(body);
        }
        function createRoadSegment(x, z, len, w, axis) {
            const geo = new THREE.PlaneGeometry(len, w); geo.rotateX(-Math.PI/2); if(axis==='z') geo.rotateY(Math.PI/2);
            const pos = geo.attributes.position; for(let i=0; i<pos.count; i++) pos.setY(i, getTerrainHeight(x+pos.getX(i), z+pos.getZ(i))+0.15);
            geo.computeVertexNormals();
            const tex = roadTexture.clone(); tex.rotation = Math.PI/2; tex.center.set(0.5,0.5); tex.repeat.set(1, len/40);
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({map:tex, color:0xffffff}));
            mesh.position.set(x,0,z); mesh.receiveShadow=true; scene.add(mesh); visualMeshes.push(mesh);
            if(Math.random()>0.8) createStreetLight(axis==='x'?x:x+12, getTerrainHeight(x,z), axis==='x'?z+12:z);
        }
        function createIntersection(x, y, z) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(22, 22), new THREE.MeshStandardMaterial({ map: crosswalkTexture, roughness: 0.8 }));
            mesh.rotation.x = -Math.PI/2; mesh.position.set(x, y, z);
            scene.add(mesh); visualMeshes.push(mesh);
            createStreetLight(x+12, y, z-12);
        }
        function createRamp() {
            for(let i=0; i<20; i++) {
                const alpha = i/20; const rX = 200 - 10; const rZ = 0 + alpha * (-200 - 0); 
                const rY = THREE.MathUtils.lerp(getTerrainHeight(rX,0), 30, alpha*alpha); 
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(15, 20), new THREE.MeshStandardMaterial({color: 0x555555}));
                mesh.rotation.x = -Math.PI/2; mesh.position.set(rX, rY, rZ);
                mesh.lookAt(rX, rY + (30-getTerrainHeight(rX,0))/20, rZ - 20); 
                scene.add(mesh); visualMeshes.push(mesh);
            }
        }
        function createStreetLight(x, y, z) {
            const g = new THREE.Group(); g.position.set(x,y,z);
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,8), new THREE.MeshStandardMaterial({color:0x222})); p.position.y=4; g.add(p);
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xffaa55})); b.position.set(0,8,0); g.add(b);
            const pl = new THREE.Mesh(new THREE.PlaneGeometry(25,25), new THREE.MeshBasicMaterial({map:lightPoolTexture, transparent:true, opacity:0, depthWrite:false, blending:THREE.AdditiveBlending}));
            pl.rotation.x=-Math.PI/2; pl.position.y=0.1; g.add(pl);
            scene.add(g); visualMeshes.push(g);
        }

        function initTraffic(count) {
            cars.forEach(c => scene.remove(c.mesh)); cars.length=0;
            const carGeo = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.8,4.5), new THREE.MeshStandardMaterial({color:0xffffff})); b.position.y=0.6; carGeo.add(b);
            const c = new THREE.Mesh(new THREE.BoxGeometry(2,0.7,2.5), new THREE.MeshStandardMaterial({color:0x88ccff, transparent:true, opacity:0.6})); c.position.set(0,1.35,-0.2); carGeo.add(c);
            
            for(let i=0; i<count; i++) {
                const car = carGeo.clone(); car.children[0].material = new THREE.MeshStandardMaterial({color:Math.random()*0xffffff});
                const onBridge = Math.random() > 0.6;
                let x,y,z,dir,axis;
                if(onBridge) { x=(Math.random()-0.5)*1500; z=-200 + (Math.random()>0.5?5:-5); y=30.5; axis='x'; dir=Math.random()>0.5?1:-1; car.rotation.y = dir>0 ? Math.PI/2 : -Math.PI/2; } 
                else { const lanes = [-400, -200, 0, 200, 400]; z = lanes[Math.floor(Math.random()*lanes.length)]; x = (Math.random()-0.5)*1500; y = 10.5; axis='z'; dir=Math.random()>0.5?1:-1; car.rotation.y = dir>0 ? 0 : Math.PI; }
                car.position.set(x,y,z); scene.add(car); cars.push({mesh:car, speed:15+Math.random()*20, dir, axis, onBridge});
            }
        }
        function updateTraffic(dt) {
            cars.forEach(c => {
                const move = c.speed * dt * c.dir;
                if(c.axis==='x') c.mesh.position.x += move; else c.mesh.position.z += move;
                if(!c.onBridge) {
                    const h = getTerrainHeight(c.mesh.position.x, c.mesh.position.z); c.mesh.position.y = h + 0.5;
                    const fwd = new THREE.Vector3(c.axis==='x'?c.dir:0, 0, c.axis==='z'?c.dir:0);
                    const target = c.mesh.position.clone().add(fwd); target.y = getTerrainHeight(target.x, target.z)+0.5;
                    c.mesh.lookAt(target);
                }
                if(Math.abs(c.axis==='x'?c.mesh.position.x:c.mesh.position.z)>1000) { if(c.axis==='x') c.mesh.position.x*=-1; else c.mesh.position.z*=-1; }
            });
        }

        // --- ğŸ¤– AI & ç¤¾äº¤ç³»ç»Ÿ ---
        function initAI_Upgraded() {
            const g = new THREE.Group();
            const core = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({color: 0x00f0ff, emissive: 0x00f0ff, emissiveIntensity: 2}));
            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.02, 8, 32), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.6}));
            const ring2 = ring1.clone(); ring2.rotation.x = Math.PI/2;
            const shell = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6, 0), new THREE.MeshBasicMaterial({color:0x00f0ff, wireframe:true, transparent:true, opacity:0.3}));
            g.add(core); g.add(ring1); g.add(ring2); g.add(shell); g.add(new THREE.PointLight(0x00f0ff, 2, 10));
            scene.add(g);
            aiDrone = { mesh: g, ring1, ring2, shell, core };
        }

        function updateAI(dt) {
            if(!aiDrone.mesh) return;
            const t = yawObject.position.clone().add(new THREE.Vector3(1.5, 0.5, -2).applyQuaternion(yawObject.quaternion));
            aiDrone.mesh.position.lerp(t, 0.05);
            aiDrone.ring1.rotation.y += dt * 2; aiDrone.ring2.rotation.x += dt * 2; aiDrone.shell.rotation.z -= dt * 0.5;
            aiDrone.core.material.emissiveIntensity = 1.5 + Math.sin(Date.now() * 0.005) * 0.5;
            
            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦è¿‡æœŸ
            if(chatTarget) {
                chatTargetTimer -= dt;
                const dist = chatTarget.position.distanceTo(yawObject.position);
                if(chatTargetTimer <= 0 || dist > 20) {
                    setChatTarget(null);
                }
            }
        }

        async function processCommand(cmd) {
            // å¦‚æœæœ‰é”å®šçš„NPCï¼Œåˆ™ä¸NPCå¯¹è¯
            if (chatTarget) {
                addLog(`(å¯¹å¸‚æ°‘ #${chatTarget.userData.id}): ${cmd}`, true);
                showBubble(playerBody, cmd, 'user'); // æ˜¾ç¤ºç©å®¶æ°”æ³¡
                
                // ç®€å•çš„NPCå“åº”é€»è¾‘
                setTimeout(() => {
                    let reply = "";
                    if(apiKey) {
                        // TODO: å¯ä»¥æ¥å…¥APIè®©NPCæ›´æœ‰æ™ºèƒ½ï¼Œè¿™é‡Œä¸ºäº†å“åº”é€Ÿåº¦å…ˆç”¨ç®€å•é€»è¾‘æˆ–å¤ç”¨API
                        fetchAIResponse(cmd, `ä½ æ˜¯ä¸€ä¸ªèµ›åšæœ‹å…‹ä¸–ç•Œçš„æ™®é€šå¸‚æ°‘ï¼ŒIDä¸º${chatTarget.userData.id}ã€‚è¯·ç”¨ç®€çŸ­çš„å£è¯­å›ç­”è·¯äººï¼š${cmd}`, (text) => {
                            npcSpeak(chatTarget, text);
                        });
                    } else {
                        // ç¦»çº¿ NPC å›å¤
                        const responses = ["å—¯ï¼Ÿä½ è¯´ä»€ä¹ˆï¼Ÿ", "åˆ«çƒ¦æˆ‘ã€‚", "è¿™å¾ˆæœ‰è¶£ã€‚", "æˆ‘ä¹Ÿè§‰å¾—ã€‚", "å°å¿ƒç‚¹ã€‚", "ä½ æ˜¯è°ï¼Ÿ"];
                        reply = responses[Math.floor(Math.random() * responses.length)];
                        npcSpeak(chatTarget, reply);
                    }
                }, 1000);
                return;
            }

            // å¦åˆ™ä¸ ECHO å¯¹è¯
            addLog(cmd, true); 
            const lowerCmd = cmd.toLowerCase();
            
            // ç³»ç»ŸæŒ‡ä»¤
            if(lowerCmd.includes('è½¦')) { switchVehicle('car'); aiSpeak("è½½å…·åˆ‡æ¢ï¼šè·‘è½¦"); return; }
            if(lowerCmd.includes('é£')) { switchVehicle('plane'); aiSpeak("è½½å…·åˆ‡æ¢ï¼šæˆ˜æœº"); return; }
            if(lowerCmd.includes('èµ°')) { switchVehicle('walk'); aiSpeak("è½½å…·åˆ‡æ¢ï¼šæ­¥è¡Œ"); return; }
            if(lowerCmd.includes('ä¸‹é›¨')) { weatherParticles.visible = true; aiSpeak("ç¯å¢ƒæ¨¡æ‹Ÿï¼šé™é›¨"); return; }

            // AI å›å¤
            if(apiKey) {
                fetchAIResponse(cmd, `ä½ æ˜¯ä¸€ä¸ªèµ›åšæœ‹å…‹ä¸–ç•Œçš„æˆ˜æœ¯AIåŠ©æ‰‹ï¼Œåå­—å«ECHOã€‚è¯·ç”¨ç®€çŸ­ã€å†·é…·ã€ç§‘æŠ€æ„Ÿçš„è¯­æ°”å›ç­”æ“ä½œå‘˜çš„è¯ï¼š${cmd}`, (text) => aiSpeak(text));
            } else {
                let reply = localKnowledge["default"][Math.floor(Math.random()*4)];
                for(let k in localKnowledge) if(cmd.includes(k)) reply = localKnowledge[k];
                aiSpeak(reply);
            }
        }

        async function fetchAIResponse(userText, promptText, callback) {
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
                });
                const data = await response.json();
                if(data.candidates && data.candidates[0].content) {
                    callback(data.candidates[0].content.parts[0].text);
                } else {
                    callback("æ•°æ®æµå¹²æ‰°ã€‚");
                }
            } catch(e) { console.error(e); callback("è¿æ¥ä¸­æ–­ã€‚"); }
        }

        function aiSpeak(text) {
            addLog(text, false);
            showBubble(aiDrone.mesh, text, 'ai');
            sfx.playChatBlip(true);
        }

        function npcSpeak(npc, text) {
            showBubble(npc, text, 'npc');
            sfx.playChatBlip(false);
            // AI å¯èƒ½ä¼šæ’å˜´
            if(Math.random() > 0.7) {
                setTimeout(() => aiSpeak(`åˆ†æå¯¹è±¡æƒ…ç»ª: ${["å¹³é™","æ¿€åŠ¨","å›°æƒ‘"][Math.floor(Math.random()*3)]}`), 2000);
            }
        }

        function showBubble(obj, text, type) {
            if(!obj) return;
            const b = document.createElement('div'); b.className = `chat-bubble ${type}`; b.innerText = text;
            ui.bubbles.appendChild(b);
            // å¦‚æœæ˜¯ç©å®¶ï¼Œä½ç½®ç¨å¾®åé«˜
            const heightOffset = type === 'user' ? 2.0 : ((obj.userData && obj.userData.height)||0.5)+0.5;
            
            // ç©å®¶æ°”æ³¡ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯cannon bodyéœ€è¦è·å–ä½ç½®
            let targetObj = obj;
            if (type === 'user') targetObj = { position: new THREE.Vector3(playerBody.position.x, playerBody.position.y, playerBody.position.z), userData: {height: 1.7} };

            activeBubbles.push({ dom: b, obj: targetObj, life: 4.0, offset: heightOffset });
            requestAnimationFrame(()=>b.style.opacity='1');
        }

        function updateBubbles(dt) {
            for(let i=activeBubbles.length-1; i>=0; i--) {
                const b = activeBubbles[i]; b.life-=dt;
                if(b.life<=0) { b.dom.style.opacity='0'; setTimeout(()=>b.dom.remove(),300); activeBubbles.splice(i,1); continue; }
                
                let pos;
                if(b.obj.position instanceof THREE.Vector3) pos = b.obj.position.clone(); // Mesh
                else pos = new THREE.Vector3(b.obj.position.x, b.obj.position.y, b.obj.position.z); // Body-like

                pos.add(new THREE.Vector3(0, b.offset, 0));
                pos.project(camera);
                
                const x = (pos.x * .5 + .5) * window.innerWidth;
                const y = (-(pos.y * .5) + .5) * window.innerHeight;
                
                if(pos.z>1 || Math.abs(pos.x)>1.1 || Math.abs(pos.y)>1.1) b.dom.style.display='none';
                else { b.dom.style.display='block'; b.dom.style.left=`${x}px`; b.dom.style.top=`${y}px`; }
            }
        }

        // --- åŸºç¡€åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050510); 
            fog = new THREE.FogExp2(0x050510, 0.002); scene.fog = fog;
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 4000);
            pitchObject = new THREE.Object3D(); pitchObject.add(camera);
            yawObject = new THREE.Object3D(); yawObject.position.y = 2; yawObject.add(pitchObject);
            scene.add(yawObject);
            renderer = new THREE.WebGLRenderer({antialias:false}); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }
        function initPhysics() {
            world = new CANNON.World(); world.gravity.set(0,-20,0);
            const m = new CANNON.Material(); world.addContactMaterial(new CANNON.ContactMaterial(m,m,{friction:0.1, restitution:0}));
            playerBody = new CANNON.Body({mass:60, material:m, fixedRotation:true, linearDamping:0.1});
            playerBody.addShape(new CANNON.Sphere(1)); playerBody.position.set(0, 10, 0); world.addBody(playerBody);
        }
        
        // --- æ§åˆ¶ & é€»è¾‘ ---
        function updatePlayer(dt) {
            const s = vehicleSettings[currentVehicle];
            const maxSpeed = touchState.isSprinting ? s.speed * 2 : s.speed;
            const input = touchState.moveVector;
            
            // è„šæ­¥å£°é€»è¾‘
            const isMoving = Math.abs(input.x) > 0.1 || Math.abs(input.y) > 0.1;
            if (isMoving && currentVehicle === 'walk') {
                sfx.playFootstep(touchState.isSprinting ? 0.3 : 0.5);
            }

            if (isMoving) {
                const angle = Math.atan2(input.y, input.x);
                const moveAngle = angle + yawObject.rotation.y + Math.PI/2; 
                const currentSpeed = input.length() * maxSpeed;
                
                if (s.fly) {
                    playerBody.velocity.x = Math.cos(moveAngle) * currentSpeed; playerBody.velocity.z = Math.sin(moveAngle) * currentSpeed;
                    const vert = touchState.isSprinting ? 10 : (Math.abs(input.length())<0.2 ? -5 : 0);
                    playerBody.velocity.y = THREE.MathUtils.lerp(playerBody.velocity.y, vert, 0.1);
                } else {
                    playerBody.velocity.x = Math.cos(moveAngle) * currentSpeed; playerBody.velocity.z = Math.sin(moveAngle) * currentSpeed;
                }
            } else {
                playerBody.velocity.x *= (1 - s.damping); playerBody.velocity.z *= (1 - s.damping);
                if(s.fly) playerBody.velocity.y *= 0.9;
            }
            yawObject.position.copy(playerBody.position); yawObject.position.y += (s.fly ? 0 : s.height);
            ui.speed.innerText = Math.round(Math.sqrt(playerBody.velocity.x**2 + playerBody.velocity.z**2));
            checkInteraction();
        }

        function setChatTarget(npc) {
            chatTarget = npc;
            if(npc) {
                chatTargetTimer = 20; // é”å®š20ç§’
                ui.targetInd.style.display = 'block';
                ui.targetId.innerText = npc.userData.id;
                ui.input.placeholder = `ä¸ å¸‚æ°‘ #${npc.userData.id} äº¤è°ˆ...`;
            } else {
                ui.targetInd.style.display = 'none';
                ui.input.placeholder = "è¾“å…¥æŒ‡ä»¤/èŠå¤©...";
            }
        }

        function checkInteraction() {
            if(renderer.info.render.frame % 10 !== 0) return;
            const rs = yawObject.position.clone(); const rd = new THREE.Vector3(0,0,-1).applyQuaternion(pitchObject.getWorldQuaternion(new THREE.Quaternion()));
            raycaster.set(rs, rd);
            const hits = raycaster.intersectObjects(interactables, true);
            const btn = document.getElementById('btn-interact');
            
            if(hits.length > 0 && hits[0].distance < 15) {
                let t = hits[0].object; while(t.parent && !t.userData.isNPC) t = t.parent;
                if(t.userData.isNPC) { 
                    btn.style.display = 'flex'; 
                    window.currentInteractionTarget = t; 
                    ui.prompt.style.display='block'; 
                    return; 
                }
            }
            btn.style.display = 'none'; ui.prompt.style.display='none'; window.currentInteractionTarget = null;
        }

        function switchVehicle(type) {
            currentVehicle = type; const s = vehicleSettings[type];
            ui.modeIcon.innerText = s.icon; ui.modeText.innerText = s.name;
            playerBody.linearDamping = s.damping; if(type==='fly') playerBody.velocity.y = 20;
        }

        function setupControls() {
            const joyZone = document.getElementById('joystick-zone');
            const joyBase = document.createElement('div'); joyBase.className = 'joystick-base';
            const joyStick = document.createElement('div'); joyStick.className = 'joystick-stick';
            joyBase.appendChild(joyStick); joyZone.appendChild(joyBase);
            let joyId = null; const joyStart = {x:0, y:0}; const maxR = 60;
            
            joyZone.addEventListener('touchstart', e => {
                e.preventDefault(); if(joyId!==null) return;
                const t = e.changedTouches[0]; joyId = t.identifier;
                const rect = joyZone.getBoundingClientRect(); joyStart.x = t.clientX - rect.left; joyStart.y = t.clientY - rect.top;
                joyBase.style.left = joyStart.x+'px'; joyBase.style.top = joyStart.y+'px'; joyBase.style.opacity=1;
            }, {passive:false});
            
            document.addEventListener('touchmove', e => {
                if(joyId===null) return;
                for(let t of e.changedTouches) if(t.identifier===joyId) {
                    const rect = joyZone.getBoundingClientRect();
                    const dx = (t.clientX - rect.left) - joyStart.x; const dy = (t.clientY - rect.top) - joyStart.y;
                    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxR); const angle = Math.atan2(dy, dx);
                    joyStick.style.transform = `translate(-50%,-50%) translate(${Math.cos(angle)*dist}px,${Math.sin(angle)*dist}px)`;
                    touchState.moveVector.set(dx, dy).normalize().multiplyScalar(dist/maxR);
                    touchState.isSprinting = (dist/maxR) > 0.9;
                    joyStick.style.backgroundColor = touchState.isSprinting ? '#ff3366' : 'rgba(0,240,255,0.8)';
                }
            }, {passive:false});
            
            document.addEventListener('touchend', e=>{ for(let t of e.changedTouches) if(t.identifier===joyId) { joyId=null; joyBase.style.opacity=0.3; joyStick.style.transform='translate(-50%,-50%)'; touchState.moveVector.set(0,0); } });

            const camZone = document.getElementById('camera-zone'); let camId = null; let lastX=0, lastY=0;
            camZone.addEventListener('touchstart', e=>{ e.preventDefault(); camId=e.changedTouches[0].identifier; lastX=e.changedTouches[0].clientX; lastY=e.changedTouches[0].clientY; }, {passive:false});
            document.addEventListener('touchmove', e=>{
                if(camId===null) return;
                for(let t of e.changedTouches) if(t.identifier===camId) {
                    const dx = t.clientX-lastX; const dy = t.clientY-lastY;
                    yawObject.rotation.y -= dx*0.005; pitchObject.rotation.x = Math.max(-1.5, Math.min(1.5, pitchObject.rotation.x - dy*0.005));
                    lastX=t.clientX; lastY=t.clientY;
                }
            }, {passive:false});
            document.addEventListener('touchend', e=>{ for(let t of e.changedTouches) if(t.identifier===camId) camId=null; });

            document.getElementById('btn-jump').addEventListener('touchstart', e=>{ e.preventDefault(); playerBody.velocity.y = 10; });
            document.getElementById('btn-car').addEventListener('touchstart', e=>{ e.preventDefault(); switchVehicle(currentVehicle==='walk'?'car':(currentVehicle==='car'?'plane':'walk')); });
            
            // äº¤äº’æŒ‰é’®ï¼šç°åœ¨ä¼šé”å®šç›®æ ‡
            document.getElementById('btn-interact').addEventListener('touchstart', e=>{ 
                e.preventDefault(); sfx.playInteract();
                if(window.currentInteractionTarget) {
                    setChatTarget(window.currentInteractionTarget);
                    const greeting = ["ä½ å¥½ï¼","ä»Šå¤©å¤©æ°”ä¸é”™ã€‚","æˆ‘åœ¨ç­‰è½¦ã€‚", "ä½ çœ‹ä¸Šå»å¾ˆä¸“ä¸šã€‚", "åˆ«æŒ¡é“ã€‚", "èµ›åšç©ºé—´è§ã€‚"][Math.floor(Math.random()*6)];
                    npcSpeak(window.currentInteractionTarget, greeting);
                } 
            });
            ui.input.addEventListener('keydown', e=>{ if(e.key==='Enter') { processCommand(ui.input.value); ui.input.value=''; } });
        }

        // --- ç¯å¢ƒ ---
        function updateEnvironment(dt) {
            dayTime=(dayTime+dt*0.001)%1; const phi=dayTime*Math.PI*2;
            sunLight.position.set(Math.sin(phi)*800, Math.cos(phi)*800, 200); sunMesh.position.copy(sunLight.position);
            const isNight = dayTime<0.25||dayTime>0.75;
            const sky = new THREE.Color(isNight?0x050510:0xffaa55);
            scene.background.lerp(sky, 0.05); fog.color.lerp(sky, 0.05); sunLight.intensity = isNight?0:1.2;
            buildingMaterials.forEach(m=>m.emissiveIntensity=THREE.MathUtils.lerp(m.emissiveIntensity, isNight?1:0, 0.05));
            ui.time.innerText = `${Math.floor(dayTime*24).toString().padStart(2,'0')}:${Math.floor((dayTime*24*60)%60).toString().padStart(2,'0')}`;
        }
        function initNPCs(count) {
            const bodyGeo=new THREE.BoxGeometry(0.6,1.2,0.4), headGeo=new THREE.BoxGeometry(0.4,0.4,0.4);
            for(let i=0; i<count; i++) {
                const g=new THREE.Group(), c=new THREE.Color().setHSL(Math.random(),0.8,0.5);
                const b=new THREE.Mesh(bodyGeo,new THREE.MeshStandardMaterial({color:c})); b.position.y=0.6;
                const h=new THREE.Mesh(headGeo,new THREE.MeshStandardMaterial({color:0xffccaa})); h.position.y=1.4;
                g.add(b); g.add(h); 
                g.position.set((Math.random()-0.5)*300,0,(Math.random()-0.5)*300); 
                // ç»™NPCå¢åŠ  ID
                g.userData={isNPC:true, height:1.8, id: Math.floor(Math.random()*9000)+1000, lastTalkTime: 0};
                scene.add(g); interactables.push(g); npcs.push({mesh:g, dir:Math.random()*6, speed:2+Math.random()*2, timer:0});
            }
        }
        function updateNPCs(dt) {
            const now = Date.now();
            npcs.forEach((n, idx) => {
                n.timer+=dt; if(n.timer>3) { if(Math.random()>0.5) n.dir+=(Math.random()-0.5)*2; n.timer=0; }
                n.mesh.position.x += Math.sin(n.dir)*n.speed*dt; n.mesh.position.z += Math.cos(n.dir)*n.speed*dt; n.mesh.rotation.y = n.dir;

                // --- ç¤¾äº¤æ£€æµ‹ï¼šNPC ä¹‹é—´äº’èŠ ---
                // æ¯éš”ä¸€æ®µæ—¶é—´æ£€æŸ¥ä¸€æ¬¡ï¼Œé¿å…æ€§èƒ½æ¶ˆè€—
                if (idx % 5 === 0 && now - n.mesh.userData.lastTalkTime > 8000) { // è‡³å°‘é—´éš”8ç§’
                    // å¯»æ‰¾æœ€è¿‘çš„å¦ä¸€ä¸ª NPC
                    for (let other of npcs) {
                        if (other === n) continue;
                        if (n.mesh.position.distanceToSquared(other.mesh.position) < 25) { // è·ç¦» < 5ç±³
                             if (now - other.mesh.userData.lastTalkTime > 8000) {
                                // è§¦å‘å¯¹è¯
                                const talk = npcDialogues[Math.floor(Math.random() * npcDialogues.length)];
                                npcSpeak(n.mesh, talk);
                                n.mesh.userData.lastTalkTime = now;
                                other.mesh.userData.lastTalkTime = now + 2000; // å¯¹æ–¹ç¨å¾®æ™šä¸€ç‚¹æ‰èƒ½å†è¯´
                                
                                // 20% æ¦‚ç‡ AI æ’å˜´è¯„ä»·
                                if(Math.random() < 0.2 && aiDrone.mesh.position.distanceTo(n.mesh.position) < 30) {
                                    setTimeout(()=> aiSpeak(`æ£€æµ‹åˆ°å¸‚æ°‘äº¤æµã€‚è¯é¢˜åˆ†æï¼š${["å¤©æ°”","ç»æµ","éæ³•æ´»åŠ¨"][Math.floor(Math.random()*3)]}`), 2000);
                                }
                                break; // åªè·Ÿä¸€ä¸ªèŠ
                             }
                        }
                    }
                }
            });
        }
        
        // --- è¾…åŠ© ---
        function addLog(txt, isUser) { const d=document.createElement('div'); d.style.color=isUser?'#fff':'#00f0ff'; d.textContent=(isUser?'> ':'> ECHO: ')+txt; ui.log.appendChild(d); ui.log.scrollTop=ui.log.scrollHeight; }
        function initVoice() { if('webkitSpeechRecognition' in window) { const r=new webkitSpeechRecognition(); r.lang='zh-CN'; const b=document.getElementById('mic-btn'); r.onstart=()=>b.classList.add('listening'); r.onend=()=>b.classList.remove('listening'); r.onresult=e=>processCommand(e.results[0][0].transcript); b.onclick=()=>r.start(); } }

        function animate(time) {
            requestAnimationFrame(animate); const dt=(time-lastTime)/1000||1/60; lastTime=time;
            if(isGameActive) {
                world.step(1/60); updatePlayer(dt); updateAI(dt); updateNPCs(dt); updateTraffic(dt); updateEnvironment(dt); updateBubbles(dt);
                spatialAudio.update(playerBody.position, cars);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
